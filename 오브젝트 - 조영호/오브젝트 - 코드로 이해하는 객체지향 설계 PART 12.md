# 오브젝트 PART 12 - 다형성

[예제 소스 코드 Link](https://github.com/eternity-oop/object/tree/master/chapter12)

### 다형성

컴퓨터 과학에서는 다형성을 하나의 추상 인터페이스에 대해 서로 다른 구현을 연결할 수 있는 능력으로 정의한다. 간단하게 말해서 여러 타입을 대상으로 동작할 수 있는 코드를 작성할 수 있는 방법이다.

객체지향 프로그래밍에서는 총 4가지 다형성을 사용할 수 있다.

1. *유니버설 → 매개변수*
    
    제네릭 프로그래밍과 관련이 높다. List 인터페이스는 컬렉션에 보관할 요소의 타입을 임의의 타입 T로 지정하고 있어 실제 인스턴스를 생성하는 시점에 T를 구체적인 타입으로 지정할 수 있게 한다.
    
2. *유니버설 → 포함 (서브타입 다형성)*
    
    메시지가 동일하더라도 수신한 객체의 타입에 따라 실제로 수행되는 행동이 달라지는 능력이다. 우리가 앞서 살펴본 ‘역할’ 개념을 통해 DiscountPolicy 인터페이스를 생성하고 하위 구현체를 통해 메서드를 실행 시점마다 다르게 호출하는 것이 예시다.
    
3. *임시 → 오버로딩*
    
    동일한 이름의 메서드이지만 인자가 다른 경우
    
4. *임시 → 강제*
    
    + 연산자는 정수형일 때는 덧셈 연산자이지만 문자열은 경우는 연결 연산자이다. 하지만 이는 어떤 메서드가 
    
    호출될 지 모호질 수 있다.
    

---

### 상속의 양면성

상속의 목적은 코드 재사용이 아니다. 프로그램을 구성하는 개념들을 기반으로 다형성을 가능케 하는 타입 계층을 구축하기 위한 것이다. 상속의 메커니즘을 이해하기 위해 필요한 몇 가지 개념들을 예시와 함께 살펴보자.

1. 데이터 관점의 상속
    
    우리가 클래스의 인스턴스를 생성하면 시스템은 인스턴스 변수를 저장할 수 있는 메모리 공간을 할당한다. 만약 GradeLecture 클래스(자식)를 생성했다면? 이 인스턴스는 직접 정의한 인스턴스 변수뿐만 아니라 부모 클래스인 Lecture가 정의한 인스턴스 변수도 함께 포함한다.
    
    이렇게 데이터 관점에서 상속은 자식 클래스의 인스턴스 안에 부모 클래스의 인스턴스를 포함하는 것으로 볼 수 있다.
    
2. 행동 관점의 상속
    
    부모 클래스가 정의한 일부 메서드를 자식 클래스의 메서드로 포함시키는 것을 의미한다. 공통적으로 부모 클래스의 모든 퍼블릭 메서드는 자식 클래스의 퍼블릭 인터페이스에 포함된다. 따라서 외부의 객체가 부모 클래스의 인스턴스에게 전송할 수 있는 모든 메시지는 자식 클래스의 인스턴스에게도 전송할 수 있다.
    
    사실 이것은 클래스의 코드가 합쳐지거나 복사되는 것이 아니다. 런타임에 시스템이 자식 클래스에 정의하지 않은 메서드를 호출하는 경우 이 메서드를 부모 클래스 안에서 탐색하기 때문에 가능하다.
    

---

### 같은 메시지, 다른 메서드

성적 통계를 계산하는 기능을 Professor 클래스가 추가하는 예시를 보자. Professor 클래스는 Lecture 타입의 인스턴스 변수를 가지며 통계 정보를 생성하기 위한 메서드는 Lecture의 evalutate(), average() 를 사용할 것이다. 그렇다면 이 때 생성자의 인자로 Lecture, GradeLecture 인스턴스가 들어가도 괜찮을까?

답은 ‘아무 문제 없다’이다. Lecture, GradeLecture 인스턴스 중 어떤 것이 들어가더라도 결과는 동일하다. 이처럼 코드 안에서 선언된 참조 타입과 무관하게 실제로 메시지를 수신하는 객체의 타입에 따라 실행되는 메서드가 달라질 수 있는 것은 업캐스팅(부모 클래스 타입으로 선언된 변수에 자식 클래스 인스턴스 할당이 가능)과 동적 바인딩(선언된 변수의 타입이 아닌 메시지를 수신하는 객체의 타입에 따라 실행시점에 메서드가 결정된다) ****메커니즘이 작용하기 때문이다.

---

### 동적 메서드 탐색과 다형성

객체지향 시스템은 아래의 규칙에 따라 실행할 메서드를 선택한다.

1. *메시지를 수신한 객체는 먼저 자신을 생성한 클래스에 적합한 메서드가 존재하는지 검사하고, 존재하면 메서드를 실행하고 탐색을 종료한다.*
2. *메서드를 찾지 못했다면 부모 클래스에서 메서드 탐색을 계속한다. 이 과정은 적합한 메서드를 찾을 때까지 상속 계층을 따라 올라가며 계속된다.*
3. *상속 계층의 가장 최상위 클래스에 이르렀지만 메서드를 발견하지 못한 경우 예외를 발생시키며 탐색을 중단한다.*

객체가 메시지를 수신하면 탐색 과정에서 컴파일러는 self 참조라는 임시 변수를 선언하고 메시지를 수신한 객체를 가리킨다. 이 후 self 변수가 가리키는 객체의 클래스에서 class 포인터를 이용해 자식 클래스부터 부모까지 탐색을 시작한다. self 변수의 역할은 꽤 중요한데, 객체가 메시지를 수신했을 때 이 메시지가 가질 수 있는 타입은 하나지만 구현체는 여러 개이다. 따라서 이 변수는 어떤 객체가 시작점인지 파악할 수 있는 시작점 역할을 해준다.

위 탐색에서 알아두어야 할 원리는 자식 클래스가 이해할 수 없는 메시지를 전송받은 경우 상속 계층을 따라 부모 클래스에게 처리를 위임하는 **‘자동 메시지 위임’**과 메시지를 수신한 후 어떤 메서드를 실행할지를 결정하는 것은 컴파일이 아닌 실행 시점이라는 **‘동적인 문맥 사용’** 이다.

---

### 동적인 문맥

위 메서드 탐색 메커니즘을 보면 우리는 결국 단순 메시지 전송 코드만으로는 어떤 클래스의 어떤 메서드가 실행되는지를 알 수 없다는 걸 확인할 수 있다. 여기서 중요한 건 메시지를 수신한 객체가 무엇이냐이다. 이에 따라 메서드 탐색을 위한 문맥이 바뀌며 이것을 결정하는 것은 바로 메시지를 수신한 객체를 가리키는 self 참조다.

---

### self 대 super

self 참조의 가장 큰 특징은 동적이라는 점이다. 이에 대비해서 super 참조(super reference)는 조금 다르다. 보통 super 참조는 자식 클래스에서 부모 클래스의 구현을 재사용했을 때 부모 클래스의 인스턴스 변수, 메서드에 접근하기 위해 사용한다.

이 때 우리는 부모 클래스의 메소드를 호출한다고 많이 표현하는데 결코 ‘부모 클래스의 메서드'를 호출하는 것이 아닌 ‘부모 클래스에게 메시지를 전송한다’라는 표현이 올바르다. 그 이유는 super 참조의 용도는 단순히 부모 클래스에 정의된 메서드를 실행하기 위한 것이 아니기 때문이다. 정확한 의도는 ‘지금 이 클래스의 부모 클래스에서부터 메서드 탐색을 시작하세요' 이다.

여기서 self 전송과 super 전송의 차이점은 메서드 탐색을 시작하는 처음 위치다. self는 메시지를 전달받은 객체, super는 해당 클래스의 부모 클래스가 메서드 탐색의 시작점이다. 

---