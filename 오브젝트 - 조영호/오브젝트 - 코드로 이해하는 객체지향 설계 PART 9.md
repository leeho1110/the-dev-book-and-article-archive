# 오브젝트 PART 9 - 유연한 설계

이름을 가진 설계 원칙을 통해 의존성 관리 기법들과 그 메커니즘을 명확하게 정리하자

---

### 개방-폐쇄 원칙(Open-Closed Principle, OCP)

> *소프트웨어 개체(클래스, 모듈, 함수 등등)는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다.*
> 

사실 이 원칙은 런타임 의존성과 컴파일타임 의존성에 대한 이야기이다. 우리가 앞서 예시로 들었던 할인 정책 설계는 이미 개방-폐쇄 원칙을 따르고 있다. 

우리가 만약 중복 할인 정책을 추가하고 싶다면? ***DiscountPolicy*** 를 상속하는 신규 클래스를 추가하면 된다. 즉 기존 클래스를 **전혀 수정하지 않은 채 확장**할 수 있다.  

위 설계는 새로운 할인 정책의 추가를 통해 기능을 확장할 수 있다. 따라서 ‘확장에 대해서는 열려 있다’. 또한 기존 코드를 수정할 필요 없이 새로운 할인 정책을 확장할 수 있다. 따라서 ‘수정에 대해서 닫혀있다’ 이것이 개방-페쇄 원칙이 의미하는 것이다.

만약 ***Movie*** 객체가 추상화된 ***DiscountPolicy*** 가 아닌 ***AmountDiscountPolicy***나 ***PercentDiscountPolicy*** 객체를 의존했다면 할인 정책을 변경해야할 때 우린 실제 내부 구현을 수정해야했을 것이고 이는 개방-폐쇄 원칙을 위반하게 된다. 개방-폐쇄 원칙의 핵심은 추상화다. 변하지 않는 부분을 고정하고 변하는 부분을 생략하는 추상화 메커니즘이 기반이 된다.

---

### 생성 사용 분리

위 예시에서는 인스턴스를 생성하지 않고 주입받는 것을 통해 개방-폐쇄 원칙을 지켰다. 그런데 결국은 어디서든 인스턴스를 생성해야 한다. 그렇다면 어디서 해야할까.

정답은 클라이언트다. 앞선 예시에서는 생성에 초점을 두고 있었다. 하지만 사실 생성은 잘못되지 않았다. 어디서 생성했는지가 잘못된 것이었다. 한 마디로 **객체에 대한 생성과 사용을 분리**하는 것이다.

---

### FACTORY 추가하기

생성 책임을 우린 클라이언트에게 옮겼다. 그렇다면 클라이언트는 특정 컨텍스트에 묶이지 않아도 되는지 확인해보자. 만약 묶이지 않길 바란다면 어떻게 해야할까.

이 때 우린 생성과 사용을 분리하지 위해 객체 생성에 특화된 객체인 ***Factory***를 생성하면 된다. 클라이언트는 ***Factory***를 통해 생성된 인스턴스를 받아서 사용하기만 하면 된다.

---

### PURE FABRICATION 패턴

우리는 책임을 정보 전문가에게 할당하는 패턴을 통해 도메인 객체들에게 적절한 책임을 할당해왔다. 하지만 앞선 예시처럼 모든 책임을 도메인 객체에게만 할당하게 되면 낮은 응집도, 높은 결합도, 재사용성 저하와 같은 문제들이 나타나게 된다.

따라서 이경우 설계자가 임의로 편의성을 위해 생성한 객체에게 책임을 할당해 문제를 해결해야 한다. 위에서 생성한 ***Factory*** 객체가 그 일부 중 하나이다.

---

### 의존성 주입

우리는 ***Factory*** 객체를 통해 생성과 사용을 분리해냈고, 이를 통해 ***Movie*** 객체에게는 인스턴스를 사용하는 책임만 남게 되었다. 이처럼 사용하는 객체가 아닌 외부의 독립적인 객체가 인스턴스를 생성한 후 이를 전달해서 의존성을 해결하는 방법을 **의존성 주입(Dependency Injection)**이라고 부른다.

---

### 추상화와 의존성 역전

```java
public class Movie {
		private AmountDiscountPolicy discountPolicy;
}
```

이 설계가 변경에 취약한 이유는 요금을 계산하는 상위 정책이 요금을 계산하는데 필요한 구체적인 방법에 의존하기 때문이다. 즉 ***Movie***는 상위 수준 클래스, ***AmountDiscountPolicy***는 하위 수준 클래스라고 볼 수 있다. 

객체 사이의 협력이 존재할 때 그 협력의 본질을 담고 있는 것은 상위 수준의 정책이다. 상위 수준의 클래스가 하위 수준의 클래스에 의존하는 것은 하위 수준 클래스의 변경에 상위 수준이 영향을 받는다는 것을 뜻한다. 이는 의존성의 방향이 잘못됐다는 것을 의미한다.

해결방법은 추상화다. 상위 수준의 클래스와 하위 수준 클래스 모두 추상화에 의존하게 되면 문제는 해결된다. 구체 클래스는 의존성의 시작점이여야지 목적지가 되서는 안된다.

> *1. 상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안된다. 둘 모두 추상화에 의존해야 한다.
2. 추상화는 구체적인 사항에 의존해서는 안된다. 구체적인 사항은 추상화에 의존해야 한다.*
> 

우리는 앞서 위 2개의 내용이 유연하고 재사용 가능한 설계에 얼마나 많은 도움이 되는지를 확인했다. 우리는 이를 **의존성 역전 원칙(Dependency Inversion Principle, DIP)**라고 부른다,

---

### 유연한 설계는 유연성이 필요할 때만 옳다

우리는 유연하고 재사용 가능한 설계란 런타임 의존성과 컴파일타임 의존성의 차이를 인식하고 동일한 컴파일타임 의존성으로부터 다양한 런타임 의존성을 만들 수 있는 코드 구조를 가지는 설계라는 것을 확인했다. 하지만 이는 항상 좋은 것은 아니다.

앞선 예시에서 우리가 만약 할인 정책에 대한 컨텍스트를 정확하게 확인하지 못한 상황이라면 어땠을까. 만약 코드를 처음 보는 상황이였다고 가정한다면 코드 상에 표현된 정적 클래스 구조와 실행 시점의 동적 객체 구조가 다르기 때문에 단순함, 명확함과는 거리가 있다고 느껴질 것이다.

설계가 유연할수록 클래스 구조와 객체 구조 사이의 거리는 멀어진다. 불필요한 유연성은 불필요한복잡성과 같다. 단순하고 명확한 설계가 필요할 때는 그렇게 하라.