# 오브젝트 - 코드로 이해하는 객체지향 설계 PART 2 : 객체지향 프로그래밍

### 영화 예매 시스템 어플리케이션 구현

우리는 온라인 영화 예매 시스템을 구축하려 한다. 우선 **‘영화’**와 **‘상영’** 을 구분할 예정이다. 그 이유는 우리는 평소 영화를 예매한다고 표현한다. 하지만 실제로 우리가 예매하는 것은 ‘상영’이다. 영화를 시청할 수 있는 권리를 구매하는 것이다. 

이 때 예매자는 특정 조건을 만족하는 경우 요금을 할인받을 수 있다. 할인액을 결정하는 규칙은 **‘할인 조건’**과 **‘할인 정책’** 이다. 할인 조건은 가격의 할인 여부를 결정하며, 할인 정책은 할인 요금을 결정한다. 할인 정책에는 금액 할인과 비율 할인이 존재한다. 할인 정책은 영화별 하나만 가능하지만 할인 조건은 다수가 가능하다. 할인을 적용하기 위해선 정책와 조건을 함께 조합하여 계산한다. 우선 이 정도의 도메인 개념만 먼저 확인하고 코드로 넘어가자. 

---

### 협력, 객체, 클래스

우리는 프로그램을 작성할 때 보통 어떤 클래스가 필요할지 먼저 생각한다. 하지만 이것은 객체지향의 본질과는 거리가 멀다고 말할 수 있다. 객체지향은 객체를 지향한다. 진정한 객체지향 패러다임으로의 전환은 어떤 클래스가 필요한지 고민하기 전에 **어떤 객체들이 필요**한지 고민해야 한다. 

클래스는 공통적인 상태와 행동을 공유하는 객체들을 추상화한 것일 뿐이다. 또한 객체를 외딴 섬이나 온갖 대포와 전투기로 만반의 태세를 갖춘 항공모함이 아닌 기능을 구현하기 위해 협력하는 공동체의 일원으로 바라봐야 한다. 이를 통해 객체들의 모양과 윤곽이 잡히면 **공통된 특성과 상태를 가진 객체들을 타입으로 분류하고 이 타입을 기반으로 클래스를 구현**하면 된다. 

> *훌륭한 협력이 훌륭한 객체를 낳고 훌륭한 객체가 훌륭한 클래스를 낳는다*

---

### 도메인의 구조를 따르는 프로그램 구조

도메인이라는 용어를 알고 있는가. 필자는 뭔가 도메인이라는 개념을 아는 듯 하지만 명확하게 정의내리긴 힘들었다. 그래서 본문에서 언급하는 내용을 그대로 인용하겠다.

> 소프트웨어는 사용자가 원하는 어떤 문제를 해결하기 위해 만들어진다. 영화 에매 시스템의 목적은 영화를 좀 더 쉽고 빠르게 예매하려는 사용자의 문제를 해결하는 것이다. 이처럼 **문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야**를 도메인이라고 부른다.

우리는 보통 도메인 구조를 미리 머릿속에 가지고 있다. 그렇기 때문에 요구사항을 분석하는 초기 단계부터 객체와 클래스를 매끄럽게 연결지을 수 있는 것이다. 즉 클래스 사이의 관계는 최대한 도메인 개념 사이에 맺어진 관계와 유사하게 만들어 프로그램의 구조를 이해하고 예상하기 쉽게 만들어야 한다. 

---

### 클래스 구현하기

클래스는 인스턴스 변수들을 갖고 이들에게는 가시성이라는 개념이 존재한다. 가시성은 눈에 보이는가에 대한 성질이다. 우리는 객체지향 언어에서 이를 표현하는 쉬운 예시를 하나 들수있다. private과 public이다.

클래스를 구현하거나 사용할 때 가장 중요한 것은 **클래스의 경계를 구분 짓는 것**이다. 어떤 부분을 외부에 공개하고 감출지 결정해야 객체의 명확성이 생기고 자연스럽게 객체의 자율성이 보장되기 때문이다. 그리고 프로그래머에게 구현의 자유를 제공한다.

우선 두 가지 핵심을 짚고 넘어가자. 객체는 상태(state)와 행동(behavior)을 함께 가지는 복합적인 존재다. 또한 스스로 판단하고 행동하는 자율적인 존재다. 우리는 절차지향과 객체지향이 어떤 점에서 다른지 알아보았다. 절차지향은 우선 데이터와 기능을 독립적인 존재로 바라보았다. 이 후 독립적인 존재들을 서로 엮어 설계를 완성했다. 반면 객체향적 패러다임에서 객체라는 단위 안에 데이터와 기능을 한 덩어리로 묶어 해결하고자 하는 영역의 아이디어를 표현하였다. 그리고 이 과정 속에서 데이터와 기능을 객체 내부에 함께 묶었고 이를 우린 **캡슐화**라고 칭했다.

객체는 스스로 상태를 관리,판단하고 행동할 때 자율적인 객체로 거듭나기에 우리는 캡슐화를 통해 객체 외/내부에 접근을 제한했다. 그리고 이는 객체를 보다 자율적으로 만들기 위해서였다. 더 나아가 우리는 외부에서의 접근을 통제할 수 있도록 접근 제어(access control) 메커니즘도 같이 적용시킬 수 있는데 *public, protected, private* 와 같은 접근 수정자(access modifier)들이 그 예시다. 

캡슐화와 접근 제어는 객체를 접근 가능한 부분인 **퍼블릭 인터페이스(pulibc interface)** 와 외부에서는 접근이 불가능하고 오직 내부에서만 접근이 가능한 부분인 **구현(implementation)** 으로 나눈다. 이렇게 객체를 접근이 가능한지에 대한 관점으로 나누는 **인터페이스와 구현의 분리(separation of interface and implementation) 원칙** 은 훌륭한 객체지향 프로그램을 만들기 위해 따라야 하는 핵심 원칙이다.

그렇다면 구현 부분을 내부에서만 접근이 가능하도록 하는 이유가 핵심 원칙이 된 이유는 무엇일까. 클라이언트 프로그래머에게 필요한 퍼블릭 인터페이스만 공개하고 구현을 클래스 작성자만 접근 가능한 1급 보안 기밀로 만들어버린 이유는 무엇일까. 잠시 다른 얘기를 해보자면 우리는 일상에서 만나는 핵미사일 영화들의 공통점을 쉽게 떠올릴 수 있다. 바로 핵미사일 발사 버튼을 주인공들이 필사의 노력을 다해 저지하는 스토리다. 그리고 대부분의 핵미사일 버튼은 지하 벙커 깊숙히 1급 보안 상태로 유지된다. 

혹시 내가 위 예시를 들었던 이유를 알겠는가? 구현 부분이 1급 기밀이 된 이유도 이와 같다. 이유는 변경에 대한 파급효과이다. 내부 구현을 맘대로 수정할 수 있는 클래스는 과장을 조금 보태 애플리케이션의 핵미사일이 된다. 만약 내부 구현을 마음대로 변경 가능하도록 한다면 클라이언트 프로그래머가 혹여나 구현을 변경하진 않을까 항상 파급효과라는 핵미사일을 걱정해야할 것이다. 하지만 우리는 구현을 감춤으로써 문제를 신경쓸 필요가 사라진다. 이처럼 변경에 대한 파급효과를 차단하기 위해 내부 구현을 감추는 것을 **구현 은닉(implementation hiding)** 이라 부른다.

---

### 협력하는 객체들의 공동체

객체지향의 장점은 객체를 이용해 도메인의 의미를 풍부하게 표현할 수 있다는 것이다. 우리는 금액의 타입을 `Long` 으로 사용했었다. 이것은 변수의 크기나 연산자의 종류와 관련된 구현 관점의 제약은 표현 가능하지만  Money 객체를 통해 표현하는 것처럼 금액과 관련된 변수라는 의미를 전달할 수 없다. 

좀더 쉽게 말하자면 Long 타입을 갖는 인스턴스 변수가 '돈'이라는 의미를 갖는다는 것을 캐치하기 위해선 변수명을 money로 짓거나 주석을 작성하거나 혹은 문서화를 시켜놓는 등의 방법이 전부라는 것이다. 따라서 우리는 좀더 명시적이고 분명하게 의미를 표현할 수 있도록 객체를 사용해 해당 개념을 구현해야 한다. 개념이 비록 하나의 인스턴스 변수만 포함하더라도 개념을 명시적으로 표현할 수 있다면 이는 설계의 명확성과 유연성을 높일 수 있다.

우리는 영화를 예매하기 위해 Reservation, Screening, Movie 인스턴스들이 내부에서 서로의 메서드를 호출하며 상호작용하도록 설계했다. 이처럼 시스템의 어떤 기능을 구현하기 위해 객체들 사이에 이뤄지는 상호작용을 **협력(Collaboration)**이라고 부른다. 

---

### 협력에 관한 짧은 이야기

앞서 객체는 다른 객체로부터 내부 상태를 숨겨야한다고 말했다. 그렇다면 과연 다른 객체에게 도움이 필요할 땐 어떻게 해야할까. 이 때 객체는 다른 객체에게 인터페이스에 공개된 행동을 수행하도록 **요청(request)**할 수 있다. 그리고 요청을 받은 객체는 자율적인 방법에 따라 요청을 처리한 후 **응답(response)**한다.

객체가 다른 객체와 상호작용할 수 있는 유일한 방법은 **메시지를 전송(send a message)** 하는 것이 전부다. 다른 객체에게 요청이 도착할 때는 객체가 **메시지를 수신(receive a message)** 했다고 이야기한다. 메시지를 수신한 객체는 스스로 메시지를 어떻게 처리할지 결정하는데, 객체가 수신한 메시지를 처리하기 위한 자신만의 방법을 우린 **메서드(method)**라고 한다. 메시지와 메서드를 구분하는 것은 굉장히 중요한데 그 이유는 이를 구분하는 것에서 **다형성(polymorphism)** 의 개념이 출발하기 때문이다. 

우리는 보통 다른 객체의 메서드를 호출한다는 표현이 익숙한데, 그 이유는 코드에서 다른 객체의 퍼블릭 인터페이스를 호출하기 때문이다. 예를 들어 Movie의 calculateMovieFee() 메서드의 처리가 필요한 상황이라고 가정해보자. 우리는 이때 메서드를 호출한다고 말할 것이다. 하지만 사실 '메서드를 호출한다'라는 표현보단 'calculateMovieFee 메시지를 전송한다'라고 말하는 것이 더 적절하다. 그 이유는 객체지향 세계에서 송신자 객체는 Movie에 해당 메서드가 존재하는지 조차 알지 못하기 때문이다. 그저 전송하는 객체는 Movie가 calculateMovieFee 메시지에 응답할 수 있다고 믿고 메시지를 전송할 뿐이다. 

calculateMovieFee() 메서드의 사용은 Movie가 메시지를 수신한 뒤 결정된다. 메시지는 다른 객체에게 책임을 위임하는 요청을 위한 수단이며, 이에 대한 처리는 메시지를 수신한 객체가 해당 처리를 위해 적합한 메서드를 선택하며 완성된다. 따라서 객체는 다른 객체에게 메서드를 호출하는 것이 아닌 메시지를 전송하는 것이 올바른 개념이라고 볼 수 있다. 

---

### 할인 요금 계산을 위한 협력 시작하기

예매 요금을 계산하기 위한 협력 관계다. Movie 객체와 할인 정책 DiscountPolicy의 관계를 중점적으로 살펴보자.

```java
public class Movie {
	
	...	
	private Money fee;
	private DiscountPolicy discountPolicy 
	...

	public Money calculateMovieFee(Screening screening) {
		return fee.minus(discountPolicy.calculateDiscountAmount(screening));
	}
}
```

혹시 이상한 점이 보이는가? calculateMovieFee() 메서드에서 어떤 할인 정책을 사용할 것인지 결정하는 코드가 어디에도 없다. 단순히 discountPolicy에게 메시지를 전송하는 것이 전부이다. 여기에는 **상속(inheritance), 다형성** 그리고 그 기반에 있는 **추상화(abstraction)** 라는 원리가 숨어있다. 자 드가자.

우리는 두 가지 할인 정책을 갖고 있었, AmountDiscountPolicy/PercentDiscountPolicy는 대부분 유사하며 계산 방식만 상이하다. 우리는 중복 제거를 위해 공통 코드를 보관할 장소인 DiscountPolicy 라는 부모 클래스를 만들었다. 

```java
public abstract class DiscountPolicy {
	private List<DiscountCondition> conditions = new ArrayList<>();

	public DiscountPolicy(DiscountCondition ... conditions) {
		this.conditions = Arrays.asList(conditions);
	}

	public Money calculateDiscountAmount(Screening screening) {
		for(DiscountCondition each : conditions) {
			if(each.isSatisfiedBy(screening)){
				return getDiscountAmount(screening);
			}
		}

		return Money.ZERO;
	}

	abstract protected Money getDiscountAmount(Screening screening);
}
```

DiscountPolicy는 DiscountCondition의 리스트를 인스턴스 변수로 가지기 때문에 하나의 할인 정책이 여러 개의 할인 조건을 포함할 수 있다는 기능이 구현되었다. 

calculateDiscountAmount 메서드는 할인 조건에 대해 Screening(상영)이 조건을 만족하는지 확인하고 만족하는 경우 getDiscountAmount를 호출한다. 이 때 호출되는 메서드는 추상 메서드이다. 

DiscountPolicy가 할인 여부, 요금 계산에 필요한 전체적인 흐름은 총괄하고 정의하지만 실제로 요금을 계산하는 부분은 추상 메서드인 getDiscountAmount에게 위임한다. 즉 DiscountPolicy 추상 클래스를 상속한 자식 클래스가 오버라이딩한 메서드가 실행되는 것이다. 이처럼 부모 클래스에 기본적인 알고리즘의 흐름을 구현하고 중간에 필요한 처리를 자식 클래스에게 위임하는 디자인 패턴을 **TEMPLATE METHOD 패턴** 이라고 부른다.

---

### 컴파일 시간 의존성과 실행 시간 의존성

앞서 우리는 Movie 클래스가 할인 정책을 구현하기 위해 인스턴스 변수로 DiscountPolicy 타입을 가지는 것을 확인했었다. 그리고 할인 정책을 반영한 영화 요금을 계산하기 위해 해당 변수에 AmountDiscountPolicy, PercentDiscountPolicy 인스턴스가 반드시 필요했다. 하지만 코드 수준에서 우리는 그 어느 것도 의존하지 않은 채 DiscountPolicy 클래스에만 의존하고 있었다. 이렇게 코드 수준에서는 전혀 몰랐던 두 인스턴스와 실행 시점에 협력 가능한 이유는 무엇일까. 바로 Movie 인스턴스를 생성하는 코드에서 DiscountPolicy 타입의 객체를 인자로 받았기 때문이다.

Movie와 DiscountPolicy처럼 어떤 클래스가 다른 클래스에 접근할 수 있는 경로를 가지거나 해당 클래스의 객체의 메서드를 호출할 경우 두 클래스 사이에 의존성이 존재한다고 말한다. 앞선 예시를 살펴보자.

Movie는 멈춰있는 코드 작성 시점에서는 DiscountPolicy와 연결되었고 의존성을 갖고 있었다. 하지만 생성자를 통해 DiscountPolicy타입의 객체를 주입받는 부분을 살펴보자.

```java
Moive avatar = new Movie("아바타",
	Duration.ofMinutes(120),
    Money.wons(10000),
    new AmmountDiscountPolicy(Money,wons(800), ...));
```

Movie가 어떤 클래스를 의존하는지 보이는가? 바로 코드 시점에선 흔적도 찾아볼 수 없었던 AmmountDiscountPolicy 클래스의 인스턴스다. 만약 PercentDiscountPolicy를 사용하고 싶으면 그냥 인스턴스를 인자로 넣어주기만 하면 된다. 

여기서 우리는 **코드의 의존성과 실행 시점의 의존성이 다르다**는 개념을 명확하게 알 수 있다. 즉 클래스 사이의 의존성과 객체 사이의 의존성은 동일하지 않을 수 있으며 확장 가능한 객체지향 설계는 코드의 의존성과 실행 시점의 의존성이 다르다는 특징을 가진다는 것도 알 수 있다.

하지만 이 둘의 의존성이 다를수록 우린 코드를 이해하기 어려워지는 단점이 있다. 반면 코드는 훨씬 유연해지며 확장 가능해진다. 즉 의존성의 차이는 양날의 검이다. 결국 훌륭한 객체지향 설계는 유연한 설계와 읽기 쉬운 코드 사이의 피말리는 줄타기(트레이드 오프)로 얻어낼 수 있다.

---

### 차이에 의한 프로그래밍

우리는 추가하려는 클래스가 기존의 어떤 클래스와 매우 흡사할 때 우리는 코드를 가져와 약간만 추가하고 수정해서 새로운 클래스를 만들고 싶을 때 **상속**이라는 방법을 사용한다. 앞서 보았던 DiscountPolicy와 AmountDiscountPolicy, PercentDiscountPoliy가 상속의 강력함을 잘 보여주는 예라고 할 수 있다.

상속을 이용하면 부모 클래스의 구현은 공유하면서도 행동이 다른 자식 클래스를 쉽게 추가할 수 있다. 이처럼 부모 클래스와 다른 부분만을 추가해서 새로운 클래스를 쉽고 빠르게 만드는 방법을 **차이에 의한 프로그래밍(programming by differnece)** 라고 부른다. 아래는 10장에서 나올 상속을 도입하기 위해 따르는 두가지 원칙이다.

>1. 두 가지 이상의 메서드가 유사하게 보인다면 차이점을 메서드로 추출하라.
>2. 부모 클래스의 코드를 하위로 내리지말고 자식 클래스의 코드를 상위 계층으로 올려라

---

### 상속과 인터페이스

상속은 부모 클래스가 제공하는 모든 인터페이스를 자식 클래스가 물려받을 때 그 가치를 온전히 발휘한다. 말하고자 하는 것은 상속의 사용 이유는 단순히 메서드나 인스턴스 변수를 재사용하는 것이 아니라는 것이다.

인터페이스는 객체가 이해할 수 있는 메시지의 목록을 정의한 것이라는 내용을 기억하는가? 상속은 자식 클래스가 자신의 인터페이스에 부모 클래스의 인터페이스를 포함하는 것을 가능케 한다. 이는 부모 클래스가 수신할 수 있는 메시지는 자식도 수신할 수 있다는 것으로도 이해할 수 있다는 것을 의미한다. 

즉 둘은 **같은 역할을 수행할 수 있는 동일한 타입**이 된다. 이처럼 자식 클래스가 부모 클래스를 대신하는 것을 우린 업캐스팅(upcasting)이라고 부른다. 

---

### 다형성

아까의 예제를 다시 살펴보자. Movie 는 DiscountPolicy 클래스에게 메시지를 전송하지만 실행 시점에 실행되는 메서드는 AmountDiscountPolicy, PercentDiscountPoliy에 오버라이딩된 메서드이다. 

동일한 메시지를 전송하지만, 메시지를 수신하는 객체의 클래스가 무엇이냐에 따라 실제로 실행되는 메서드는 달라진다. 즉 동일한 메시지를 수신했을 때 객체의 타입에 따라 다르게 응답할 수 있는 능력을 우리는 **다형성**이라고 부른다. 이는 컴파일 타임 의존성과 런타임 의존성이 다르다는 사실에 기반한다. 

다형성은 동일한 메시지를 수신했을 때 객체의 타입에 따라 다르게 응답하는 능력이라고 했다. 따라서 다형적인 협력에 참여하는 객체들은 모두 같은 메시지를 이해할 수 있어야 한다는 것인데 이는 **인터페이스가 동일**해야 한다는 것을 의미한다. 앞서 예시로 설명하자면 AmountDiscountPolicy와 PercentDiscountPolicy는 DiscountPolicy라는 공통의 인터페이스를 물려받았기(공유) 때문에 다형적 협력에 참여할 수 있었다. 그리고 이 인터페이스를 통일시키기 위해서 사용한 구현 방법이 바로 상속이었다.

우리는 메시지와 메서드를 컴파일 시점(코드 수준)이 아닌 실행 시점에 바인딩했다. 이를 **지연 바인딩(lazy binding)** 또는 **동적 바인딩(dynamic binding)** 이라고 한다. 반대로 컴파일 시점에 실행될 함수나 프로시저를 결정하는 것을 **초기 바인딩(early binding)** 또는 **정적 바인딩(static binding)** 이라고 부른다. 객체지향에서 런타임과 컴파일타임의 의존성이 분리될 수 있는 결정적인 이유는 바로 정적 바인딩 메커니즘을 사용하기 때문이다.

> **구현 상속과 인터페이스 상속**
>
> 상속은 구현 상속과 인터페이스 상속으로 분류할 수 있다. 상속은 구현 상속(코드의 재사용하기 위한 목적)이 아니라 인터페이스 상속(다형적인 협력을 위해 부모 클래스와 자식 클래스가 인터페이스를 공유)을 위해 사용해야 한다.

---

### 인터페이스와 다형성

우리는 DiscountPolicy를 구현을 공유하고 싶어 추상 클래스로 구현했다. 그렇다면 만약 구현은 공유할 필요 없이 인터페이스만 공유하고 싶은 경우에는 어떻게 하면 될까. 이 때는 **인터페이스**라는 프로그래밍 요소를 활용할 수 있다. 그리고 이것이 가능한 이유 역시 다형성이다. 

인터페이스를 상속한 각 객체들은 서로의 퍼블릭 인터페이스만을 공개하고 메시지를 통해 다른 객체에게 협력을 요청한다. 앞에서 동일한 인터페이스를 공유한다면 역할을 대체할 수 있다는 것을 확인했다. 인터페이스를 상속해도 상속하는 객체와 오리진의 차이점이 없다는 것을 의미한다. 따라서 클라이언트에게도 영향을 끼치지 않는다. 다형적으로 협력한다는 것은 참으로 놀라운 일이 아닐 수 없다. 

---

### 추상화의 힘

우리는 추상화를 사용해서 상위 정책인 할인 정책 DiscountPolicy 라는 큰 개념을 통해 세부적인 금액 할인 정책 AmountDiscountPolicy와 비율 할인인 PercentDiscountPolicy 정책을 무시한 채 상위 정책을 표현할 수 있었다. 

이는 세부사항에 억눌리지 않고 상위 개념만으로도 도메인의 중요한 개념을 설명할 수 있다는 것을 의미한다. 또한 이는 기본적인 애플리케이션의 협력 흐름을 추상화를 이용해 기술할 수 있다는 사실도 내포한다.

---

### 유연한 설계

아까 우리는 할인 정책이 없는 경우를 고려하지 못했다. 이 경우에는 어떻게 해야할까.

```java
public class Movie {
	
	...	
	private Money fee;
	private DiscountPolicy discountPolicy 
	...

	public Money calculateMovieFee(Screening screening) {
		if(discountPolicy = null) {
			return fee;
		};
		return fee.minus(discountPolicy.calculateDiscountAmount(screening));
	}
}
```

문제점이 보이는가? 우리는 앞서 할인 금액을 결정하는 책임을 쭉 DiscountPolicy 타입을 갖는 인스턴스에게 위임했다는 것을 기억해야 한다. 코드를 확인해보자. calculateMovieFee()에서 할인 정책 인스턴스가 없을 때 할인 금액을 결정하는 책임이 DiscountPolicy 에서 Movie 로 넘어가는 것이 보이는가? 이럴때 우리가 일관성을 지키기 위해 어떻게 해야할까. 

정답은 할인 요금을 계산할 책임을 그대로 DiscountPolicy 계층에 유지시키는 것이다. DiscountPolicy 타입을 갖는 NoneDiscountPolicy 클래스를 추가하면 깔끔하게 끝난다. 기존의 클래스를 수정하지 않고 새로운 클래스를 추가하는 것만으로 우린 애플리케이션의 기능을 가볍게 확장했다. 이처럼 추상화를 중심으로 코드의 구조를 설계하면 유연하고 확장 가능한 설계를 만들 수 있다. 하지만 추상화가 필요한 곳은 유연성이 필요한 곳이다. 유연성이 필요할 때 추상화를 사용하라.

---

### 코드 재사용, 상속, 합성

우리는 코드를 재사용하기 위해 상속을 사용한다. 하지만 상속보다는 **합성(composition)** 이 더 좋은 방법이라 알려져 있다. 합성은 다른 객체의 인스턴스를 자신의 인스턴스 변수로 포함해서 재사용하는 방법을 말하는데 어째서 합성이 더 좋은 방법일까.

상속은 사실 캡슐화를 위반하는 점과 설계를 유연하지 못하게 만든다는 점에서 설계에 안좋은 영향을 미친다. 상속을 이용하기 위해선 부모 클래스의 구현이 자식 클래스에 노출되야 하며 이는 캡슐화를 약화시키는 결과를 초래한다. 결과적으로는 자식이 부모에 강하게 결합되기 때문에 부모의 변경 시 자식 클래스도 함께 변경될 확률도 높다. 또한 상속은 부모 클래스와 자식 클래스 사이의 관계를 컴파일 시점에 결정한다. 따라서 런타임 시점에 객체의 종류를 변경하는 것이 불가능하다. 

반면 합성은 위 두가지 문제를 모두 해결한다. 앞선 Movie에서 할인 정책은 DiscountPolicy 타입으로 인스턴스 변수에 선언되어 있었다. Movie는 단지 DiscountPolicy가 외부에 calculateDiscountAmount 메서드를 제공한다는 사실만 알고 있고, 내부 구현에 대해서는 어떤 정보도 알고 있지 않다. 따라서 각 정책에 대한 할인 내부 구현을 효과적으로 캡슐화할 수 있다. 또한 의존하는 인스턴스도 변수를 변경해주는 메서드를 통해 쉽게 교환할 수 있었다. 따라서 코드 재사용에는 상속보다는 합성이 더 좋은 방법이다.

물론 상속을 절대 사용하지 말라는 것이 아니다. 대부분은 이 둘을 적절히 배합하는 것이 좋다. 결국 Movie는 DiscountPolicy와 합성 관계이며, DiscountPolicy는 AmountDiscountPolicy, PercentDiscountPolicy와 상속 관계다. 이처럼 코드를 재사용하는 경우에는 상속보다 합성을 사용하는 것이 맞지만 다형성을 위해 인터페이스를 재사용하는 경우는 둘을 적절히 조합해 함께 사용할 수밖에 없다.

> 보다 자세한 이해는 [상속과 합성에 관하여](https://hue-dev.site/engineering/2021/05/20/%EC%83%81%EC%86%8D%EA%B3%BC-%ED%95%A9%EC%84%B1%EC%97%90-%EA%B4%80%ED%95%98%EC%97%AC.html) 링크를 참조하면 더 좋을 듯 하다.
