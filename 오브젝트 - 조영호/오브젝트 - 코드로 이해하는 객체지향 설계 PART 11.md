# 오브젝트 PART 11 - 합성과 유연한 설계

### [코드 재사용을 위해서는] 객체 합성이 클래스 상속보다 더 좋은 방법이다

상속과 합성은 객체지향 프로그래밍에서 가장 널리 사용되는 코드 재사용 기법이다. 상속을 통해 자식 클래스는 부모 클래스의 정의 대부분을 물려받게 되며 부모 클래스와 다른 부분만 추가하거나 재정의함으로써 기존 코드를 쉽게 확장할 수 있다. 하지만 부모  클래스의 내부 구현에 대해 상세하게 알아야 하기 때문에 자식 클래스와 부모 클래스의 결합도가 높아질 수 밖에 없다.

이와는 다르게 합성은 구현에 의존하지 않는다. 합성은 내부에 포함되는 객체의 구현이 아닌 퍼블릭 인터페이스에 의존한다. 또한 상속 관계는 클래스 사이의 정적 관계지만 합성 관계는 객체 사이의 동적 관계다. 이것은 상속 관계는 코드 작성 시점에 변경이 불가능하지만 합성 관계는 실행 시점에 동적으로 변경이 가능하다는 걸 의미한다.

---

### 불필요한 인터페이스 상속 문제: `java.util.Properties, java.util.stack`

앞서 Hashtable 클래스와 Properties 클래스 사이의 상속 관계에서는 불필요한 부모 클래스 Hashtable 의 오퍼레이션들이 Properties의 퍼블릭 인터페이스를 오염시켰었다. 하지만 이를 합성 관계로 수정하면 클라이언트는 오직 Properties에서 정의한 오퍼레이션만 사용할 수 있게 된다.

이로써 Hastable이 Properties의 규칙을 어길 위험성은 사라진다. 즉 내부 구현에 밀접하게 결합되는 상속과 달리 합성으로 변경한 경우 Properties는 Hastable의 내부 구현에 대해 알지 못한다. 단지 퍼블릭 인터페이스를 통해서만 Hastable과 협력하여 잘못 사용할 수 있는 가능성을 깔끔하게 제거한 것이다.

---

### 메서드 오버라이드의 오작용 문제: `InstrumentedHashSet`

앞서 Properteies, Stack 예시는 불필요한 오퍼레이션이 퍼블릭 인터페이스에 스며드는 것을 방지하기 위한 목적으로 합성을 사용했다. 물론 구현 결합도를 제거하고 퍼블릭 인터페이스를 그대로 상속받기 위한 목적은 동일하지만 이 경우는 조금 다르다.

이 경우는 자바의 인터페이스를 통해 문제를 해결할 수 있다. HastSet은 Set 인터페이스의 구현체 중 하나이다. 따라서 InstrumentedHashSet 역시 Set 인터페이스를 실체화하고 HastSet 인스턴스를 합성하면 목적을 이룰 수 있다.

---

### 상속으로 인한 조합의 폭발적인 증가

우리는 Phone 클래스의 예시를 통해 추상 클래스, 추상 메서드를 활용하더라도 상속을 사용함으로서 부모와 자식 클래스의 결합도가 굉장히 높아진다는 것을 보았다. 또한 요구사항을 추가할 때에도 이를 만족하기 위한 다양한 경우의 클래스를 추가하는 방법을 사용할 수 밖에 없었다. 

이처럼 상속의 남용으로 인해 하나의 기능을 추가하기 위해 필요 이상으로 많은 수의 클래스를 추가해야 하는 경우를 가리켜 **클래스 폭발(class explosion)** 혹은 **조합의 폭발(comibational explosion) 문제**라고 부른다.이 문제는 상속의 근본적인 한계때문에 발생한다. 상속을 통해 자식 클래스가 부모 클래스의 구현에 강하게 결합되는 결과가 강제되기 때문이다. 

컴파일타임에 자식 클래스와 부모 클래스의 관계가 고정됨에 따라 변경이 불가능하게 되고 둘 사이의 다양한 조합이 필요한 상황에서 새로운 클래스 추가가 유일한 해결방법인 상황이 초래된다. 이 문제를 해결하기 위한 방법은 단 하나 상속을 포기하는 것이다.

---

### 합성 관계로 변경하기

우리는 위 문제를 컴파일타임 의존성을 구체적인 런타임 의존성으로 대체(생성자를 통해 주입)하는 것을 통해 이 문제를 해결할 수 있다.  

핵심은 ‘역할' 이다. 구현 시점에 객체들의 관계를 고정시킬 필요가 없으며 실행 시점에 객체들의 관계를 유연하게 변경할 수 있게 된다. 상속은 런타임 의존성과 컴파일타임 의존성을 동일하게 만들지만, 합성은 이 둘을 멀리 떨어뜨려 유연한 설계를 가능케 한다.

---

### 믹스인 (Mixin)

객체를 생성할 때 코드 일부를 클래스 안에 섞어 넣어 재사용하는 기법을 가리키는 용어다. 예제가 쉽게 이해되지 않는다. 앞선 내용부터 숙달 후 다시 보는 게 좋을 것 같다.