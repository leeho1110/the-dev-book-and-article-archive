# 오브젝트 PART 14 - 일관성 있는 협력

[예제 소스 코드 Link](https://github.com/eternity-oop/object/tree/master/chapter14)

### 비일관성

우리는 새로운 통화 요금의 부가정책을 구현하기 위해 **FixedFee, TimeOfDyaDiscount, DayOfWeek** 클래스를 구현했다. **문제는 여기서 시작된다. 셋은 같은 개념으로 연관되어 있지만 구현은 모두 제각각이다.

우리는 유사한 요구사항을 구현하는 코드는 유사한 방식으로 구현될 것이라 예상한다. 우선 일관성 없는 코드는 아래와 같은 문제점을 갖는다.

1. *새로운 구현을 추가할 때 지금까지 개발된 요구사항 중 어떤 것에 맞춰 개발해야 하는지 결정하기 힘들다*
2. *코드를 이해하기 어렵다*

결론은 유사한 기능은 서로 다른 방식으로 구현해서는 안된다는 것이다. 유사한 기능은 유사한 방식으로 구현해야 한다.

---

### 설계에 일관성 부여하기

일관성 있는 설계를 하기 위해선 사실 많은 경험이 필요하다. 하지만 그것이 아니라면 히스토리 속의 Best practice를 찾는게 맞지 않겠는가? 우리는 이런 Best Practice들을 모아놓은 것들을 이미 알고 있다. 바로 디자인 패턴이다. 물론 디자인 패턴이 항상 정답이 아닐수도 있다. 이 때는 어떻게 해야할까. 아래 지침을 따라보자.

1. 변하는 개념을 변하지 않는 개념으로부터 분리하라.
2. 변하는 개념을 캡슐화하라.

이 두가지 지침의 핵심은 결국 추상화에 의존하도록 만드는 것이다. 추상화에 대한 의존은 결합도를 낮추고 대체 가능한 역할로 구성된 협력을 설계할 수 있도록 한다. 즉 추상화의 품질이 캡슐화의 품질을 결정한다.

---

### 캡슐화 다시 살펴보기

OOP의 특성을 배울 때 우린 캡슐화는 데이터 은닉이라는 장점을 갖는다고 배웠다. 데이터 은닉은 외부에 공개된 메서드(퍼블릭 인터페이스)를 통해서만 객체 내부에 접근할 수 있도록 제한하고 이를 통해 객체의 상태 구현을 숨기는 기법이다. 하지만 사실 캡슐화는 이것 외에도 더 많은 장점들을 갖고 있다.

우리는 앞서 객체를 설계할 때 내부 구현가 퍼블릭 인터페이스를 분리하여 객체를 캡슐화했었다. 이것은 단순히 자주 변경되는 내부 구현의 수정이 협력에 영향을 끼치지 않도록 하는 목적이었지만 결국은 소프트웨어 안에서 변할 수 있는 ‘개념'을 감추는 것이라고 볼 수 있다. 즉 코드 수정으로 인한 파급효과를 제어할 수 있는 기법이라면 모두 캡슐화라는 것이다.

---