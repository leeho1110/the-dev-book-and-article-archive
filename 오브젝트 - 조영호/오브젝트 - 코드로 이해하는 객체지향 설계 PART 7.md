# 오브젝트 PART 7 - 객체 분해

### 프로시저 추상화와 데이터 추상화

우리가 사용하는 프로그래밍 언어들은 어떻게 탄생했을까. C, C++, Java, Python, Javascript, Ruby, Go 등 수도 없이 많다. 그리고 이들은 점점 더 발전해나가고 있다. 이것은 사실 컴퓨터 프로그래밍이라는 복잡한 작업을 좀더 효과적으로 처리하기 위한 개발자들의 노력이다. 프로그래밍 언어들은 끝없은 숫자들이 나열된 어셈블리어를 인간의 눈높이에 맞춰 처리하기 위해 생겨나고 발전했다. 결국 프로그래밍 언어라는 것은 컴퓨팅의 복잡성에서 인간이 쉽게 이해하기 위해 만들어진 추상화다.

프로그래밍 언어들은 탄생한 이후 끊임없이 발전했고 이는 다양한 프로그래밍 패러다임의 탄생으로 이어진다. 프로그래밍 패러다임이란 시스템을 어떻게 분해할 것인지를 결정하는 원칙과 방법의 집합이다. 따라서 이는 추상화의 종류와 이를 통해 소프트웨어를 분해하는 방법에 따라 다르다.

현대적인 언어에서 추상화(메커니즘)의 종류는 프로시저 추상화와 데이터 추상화로 갈린다. 프로시저 추상화는 소프트웨어가 무엇을 해야하는지를, 데이터 추상화는 소프트웨어가 무엇을 알아야 하는지를 추상화한다. 둘 중 하나를 결정했다면 프로시저 추상화에서는 기능 분해로, 데이터 추상화에서는 타입 혹은 프로시저를 추상화한다. 우리가 지금까지 배운 객체지향 패러다임은 이 중 후자인 **데이터를 중심으로 프로시저를 추상화**하는 것이다.

> 우리는 앞서 객체지향 패러다임을 역할과 책임을 수행하는 자율적인 객체들으 협력 공동체를 구축하는 것으로 설명했다. 여기서 '역할과 책임을 수행하는 객체가'가 바로 객제치향 패러다임이 이용하는 추상화다.
> 
> 
> 기능을 '협력하는 공동체'를 구성하도록 객체들로 나누는 과정이 바로 객체지향 패러다임에서의 분해를 의미한다.
> 

---

### 프로시저 추상화와 기능 분해

이번 에제는 급여 관리 시스템이다. 위 시스템을 기능 분해 방법을 통해 구현하며 전통적인 하향식 접근법을 통해 기능 분해를 진행핼 때 발생하는 문제점들을 이해하며 객체지향적인 접근이 이에 비해 어떤 이로운 점들이 있는지 살펴보려 한다.

급여 관리 시스템은 직원들에게 매달 지급하는 기본급에 대해 직원가 협의하고 12개월동안 동일하게 지급한다. 이 때 세율에 따라 세금을 공제한다. 이 기능을 제공하는 시스템을 구축한다고 가정하고 기능을 분해해보자. 시스템의 최상위 기능은 급여를 계산하는 것이다.

하향식 접근법은 상위 기능의 추상화 수준보다 낮아야 한다. 큰 기능을 작은 기능으로 쪼개는 구조이기 때문이다. 기능 분해의 산출물은 최상위 기능을 수행하는데 필요한 절차들을 실행 순서에 따라 나열한 결과이다. 위 방법에서는 기능이 주연이며 데이터는 조연이다. 즉 기능 분해를 위해 적용되는 하향식 접근법은 기능을 먼저 생각하고 이를 분해하고 정제하는 과정에서 데이터의 종류와 저장 방식을 식별한다. 그렇다면 이 방식이 어떤 문제를 갖는지 확인해보자.

---

### 하향식 기능 분해

앞서 급여 지급 시스템을 하향식 접근법을 통해 구축했다(고 치자). 위 설계는 최상위 계층부터 메인 함수로 정의한 뒤 세부사항을 쪼개 논리적이고 체계적인 구조를 가질 수 있다. 하지만 이러한 접근법은 사실 현실에서는 문제에 휩싸이게 되는데 그 문제들은 아래와 같다.

1. **시스템의 메인 함수는 사실 하나가 아니다. 매우 많다.**
대부분으 시스템에는 핵심 기능들이 다양하며 많다. 최초 버전에서 시간이 지나며 새로운 요구사항이 생기며 위 기능들을 추가하게 된다. 그리고 이들은 각기 독립된 핵심 기능이다. 버트란드 마이어는 이렇게 말한다. "실제 시스템에 정상(top)이란 존재하지 않는다.
2. **기능이 추가되거나 요구사항이 변경되면 메인 함수를 수정해야한다**
하향식 접근법에 따르면 새로운 기능이 추가될 때마다 메인 함수를 수정해야 한다. 이는 메인 함수의 버그를 만들 확률을 높힌다.
3. **비즈니스 로직이 사용자의 인터페이스와 결합된다**
하향식 접근법은 최초 정의되는 메인 함수의 기능이 입력과 출력의 양식을 동시에 언급하며 고민한다. 즉 사용자 인터페이스와 비즈니스 로직을 섞어 관심사의 분리가 어렵다. 이는 둘의 강한 결합을 유발하고 자주 변경되는 인터페이스때문에 비즈니스 로직이 영향을 받는 불안정성을 내포하게 만든다.
4. **시간에 따른 함수 실행 순서가 고정되어 유연성과 재사용이 저하된다**
하향식 접근법 설계는 최상위 기능을 세부적으로 분해하고 그 순서를 결정한다. 이것은 처음부터 세부 기능을 어떻게 구현해야 할지 고민하도록 만든다. 실행 순서와 실행되기 위한 조건들을 미리 결정해야하기 때문에 기능들은 세부적으로 분해되더라도 중앙집중 제어 스타일을 띄게 된다. 하지만 이렇게 정해진 함수의 제어 구조는 자주 변경되며 상위 수준에 강하게 결합된다. 따라서 재사용이 어려워지며 자연스레 변경에 취약해진다.
5. **데이터 형식의 변경되면 그 파급효과를 예측할 수 없다**
    
    '하향식 기능 분해의 가장 큰 문제점은 어떤 데이터를 어떤 함수가 사용하고 있는지를 추적하기 어렵다는 것'이다. 따라서 데이터에 대한 영향도를 파악하기 어렵다.
---

### 정보 은닉과 모듈

소프트웨어와 관련된 공부를 하다보면 정보 은닉이라는 단어는 정말 쉽게 접한다. 그렇다면 혹시 정보 은닉의 뜻이 무엇인지 알고 있는가? 정보 은닉은 소프트웨어 개발에서 사용되는 시스템을 모듈 단위로 분해하기 위한 원리 중 하나다. 이 원칙의 핵심은 시스템에서 자주 변경되는 부분을 상대적으로 덜 변경되는 안정적인 인터페이스 뒤로 감추는 것이며, **복잡성과 변경 가능성** 두 가지를 감춰야 한다. 

그렇다면 정보 은닉은 시스템은 어떻게 모듈 단위로 분해할까. 우선 시스템이 감춰야할 비밀을 찾은 뒤, 외부에서 비밀에 접근하지 못하도록 울타리를 둘러치면 된다. 우리는 이를 퍼블릭 인터페이스라고 부른다.

---

### 변경을 기준으로 선택하라

단순히 클래스를 구현 단위로 사용한다는 것이 객체지향 프로그래밍을 한다는 것을 의미하지는 않는다. 만약 클래스 내부에 인스턴스의 타입을 표현하는 변수가 있고, 이 값을 기반으로 메서드 내에서 타입을 명시적으로 구분하는 방식은 객체지향을 위반하는 것으로 간주된다. 

만약 타입 변수를 이용한 조건문으로 처리한다면 우리가 앞서 얘기해왔던 변경에 영향을 받는 설계가 탄생하기 때문이다. 하지만 객체지향은 추상화를 통해 타입을 캡슐화한다. 이를 통해 시스템에 로직을 추가할 때에는 클라이언트 코드를 수정할 필요도 없었다.

이처럼 기존 코드에 아무런 영향도 미치지 않고 새로운 객체 유형과 행위를 추가할 수 있는 객체지향의 특성을 **개방-폐쇄 원칙(Open-Closed Principle, OCP)**라고 부른다.