# 오브젝트 PART 13 - 서브클래싱과 서브타이핑

우린 상속에 대한 두 가지 불신이 있는데 이를 해겷기 위해 두 가지 용도로 사용된다는 것을 이해해야 한다.

1. **타입 계층을 구현하는 것**
    
    우리는 주로 공통된 기능을 가지는 객체가 있을 때 일반적인 개념을 부모 클래스에, 특수한 개념을 자식 클래스에 구현한다. 이는 부모 클래스가 일반화(generalization), 자식 클래스가 부모 클래스의 특수화(specialization)이라는 것을 의미한다.
    
2. **코드 재사용**
    
    상속은 간단한 선언으로 부모 클래스의 코드를 재사용하여 애플리케이션의 점진적인 확장이 가능하다. 하지만 이는 궁극적으로 부모 클래스와 자식 클래스의 강결합을 야기한다. 
    

---

### 타입(개념 관점, 프로그래밍 언어 관점, 객체지향 패러다임 관점)

타입은 개념 관점에선 공통적인 특징을 공유하는 대상의 분류, 프로그래밍 언어 관점에서는 동일한 오퍼레이션을 수행하는 인스턴스들의 집합이다.

이 개념을 객체지향에서 조합해보자면 공통 특징을 가지며, 동일한 오퍼레이션을 수행할 수 있는 객체들의 조합이 바로 타입이다. 그리고 동일한 오퍼레이션은 퍼블릭 인터페이스로 치환될 수 있다. 결국 객체지향에서 타입이란 행동이 핵심이다. 동일한 행동을 제공한다면 같은 타입의 객체라는 것을 명심하자.

------

### 타입 사이의 포함 관계

타입은 다른 타입에 포함될 수 있다. 타입 계층을 구성하는 타입 간의 관계에서 조금 더 일반적인 타입을 우린 **슈퍼타입(super type),** 좀더 특수한 타입을 **서브타입(sub type)**이라고 부른다. 오라클의 슈퍼 타입과 서브 타입을 알고 있다면 동일한 개념으로 바라보면 된다.

그렇다면 이를 객체지향 패러다임에서 객체의 시각으로 바라보면 어떻게 될까. 본문에서는 아래와 같이 인용했다.

> *슈퍼타입이란 서브타입이 정의한 ‘퍼블릭 인터페이스'를 일반화시켜 상대적으로 범용적이고 넓은 의미로 정의한 것이다.

서브타입이란 슈퍼타입이 정의한 ‘퍼블릭 인터페이스’를 특수화시켜 상대적으로 구체적이고 좁은 의미로 정의한 것이다.*
> 

결국 이는 보다 일반적인 퍼블릭 인터페이스를 가지는 객체들은 더 특수한 퍼블릭 인터페이스를 가지는 객체들의 슈퍼타입이라는 것이다. 또한 이는 서브타입의 인스턴스는 슈퍼타입의 인스턴스로 간주될 수 있다는 것을 의미한다. 왜냐? 더 같은 타입안에서 단지 특수화된 것일 뿐이니까. 이것이 핵심이다.

---

### is-a 관계

우리는 앞서 상속은 자식과 부모의 강결합을 유발하지만 타입 계층을 구현하기 위해서라면 사용될 수 있다는 것을 확인했다. 그렇다면 과연 타입 계층을 구현한다는 것은 정확히 어떤 조건을 만족해야 하는 것일까.

1. 상속 관계가 is-a 관계를 모델링하는가?
    
    *ex. 객체지향 언어는 프로그래밍 언어이다.*
    
2. 클라이언트 입장에서 부모 클래스의 타입으로 자식 클래스를 사용해도 무방한가?
    
    *우리는 연락하기 위해 휴대폰을 사용해도 되는가 → 무전기로 대체되어도 무방한가*
    

이 때 중요한 질문은 2번이다. 1번은 펭귄 예시를 통해 배신 가능성이 있다는 것을 확인할 수 있다. 펭귄은 새다→ is-a를 만족한다, 새는 날 수 있다 → is-a를 만족한다. 펭귄이 날 수 있는가? 아니다.

결국 우리는 또 다시 같은 결론을 얻는다. 타입 계층을 구성하는 핵심은 **행동**에 있다.

---

### 행동 호환성

우리는 행동에만 집중하기로 했다. 물론 펭귄과 새는 동일해보이지만 결국 달랐다. 그렇다면 우리는 이것을 객체 관점에서 어떻게 확인해야할까. 정답은 클라이언트다. 

두번째 예시를 보자. 클라이언트의 관점에서 휴대폰과 무전기는 ‘연락하기 위해’ 사용된다면 둘 중 어느 것이나 상관없다. 클라이언트가 두 타입이 동일하게 행동할 것이라고 기대한다면 두 타입을 타입 계층으로 묶을 수 있다는 것이다.

---

### 클라이언트의 기대에 따라 계층 분리하기

우리는 상속 계층을 구성할 때 클라이언트의 기대에 따라 분리해야 한다. 그래야만 모든 클래스들이 펭귄과 새처럼 행동 호환성을 어길 수 없고 이에 따른 잘못된 객체와의 협력도 일어나지 않는다.

인터페이스는 결국 클라이언트가 기대하는 바에 따라 분리돼야 한다. 이렇게 클라이언트가 기대하는 바에 따라 분리하게 되면 변경에 대한 영향을 좀더 세밀하게 제어할 수 있게 되고 이렇게 구성되어야만 요구사항이 달라지더라도 파급효과를 제어할 수 있다.

이처럼 인터페이스를 클라이언트의 기대에 따라 분리하여 변경에 의한 영향을 제어하는 설계 원칙을 인터페이스 분리 원칙(Interface Sergregation Principle, ISP)라고 부른다.

---

### 서브클래싱과 서브타이핑

아까 상속의 목적이 두 가지였던 것을 기억하는가. 제목은 그 둘을 위한 것이다. 코드를 재사용할 목적으로 상속을 사용하는 경우는 서브클래싱, 타입 계층을 구성하기 위해 상속을 사용하는 경우는 서브타이핑이라고 부른다.

이 둘은 행동의 호환성에 따라 다르게 불리기도 한다. 서브클래싱은 자식과 부모 클래스의 행동이 호환되지 않기 때문에 인스턴스를 대체할 수 없어 구현 상속 혹은 클래스 상속이라고 불리며, 서브타이핑은 그 반대로 인터페이스 상속이라고 불린다.

서브타이핑은 행동 호환성과 그에 따른 대체 가능성을 포함하지만 서브클래싱은 불가능하다. 결국은 행동 호환성과 대체가능성을 지켜야만  올바른 상속 관계를 구축할 수 있다는 것이다. 그리고 이 지침은 **리스코프 치환 원칙**이라는 이름으로 정리되어 소개되었다.

> ***리스코프 치환 원칙(Liskov Substitution Principle, LSP)***
> 
> 
> 여기서 요구되는 것은 다음의 치환 속성과 같은 것이다. S형의 각 객체 o1에 대해 T형의 객체 o2가 하나 있고, T에 의해 정의된 모든 프로그램 P에서 T가 S로 치환될 때, P의 동작이 변하지 않으면 S는 T의 서브타입이다. 
> 

리스코프 치환 원칙은 자식 클래스가 부모 클래스를 대체하기 위해서는 부모 클래스에 대한 클라이언트의 가정을 준수해야 한다는 것을 강조한다. 결국 이는 클라이언트와 격리한 채로 본 모델은 의미 있게 검증하는 것이 불가능하다라는 아주 중요한 결론을 이끈다. 어떤 모델의 유효성은 클라이언트 관점에서만 검증이 가능하다는 것이다.

---

### 계약에 의한 설계(Design By Contract)

클라이언트와 서버 사이의 협력을 의무와 이익으로 구성된 계약의 관점에서 표현하는 것을 말한다. 여기에는 클라이언트가 정상적으로 메서드를 실행하기 위해 만족시켜야 하는 **사전조건**과 메서드가 실행된 후 서버가 클라이언트에게 보장해야하는 **사후조건**, 메서드 실행 전후로 인스턴사 만족시켜야 하는 **클래스 불변식**으로 구성된다.

리스코프 치환 원칙은 어떤 타입이 서브타입이 되기 위해서는 클라이언트 관점에서 둘이 대체되더라고 협력에 지장이 없어야 한다는 것을 의미한다. 이 때 협력에 지장이 없어야 한다는 조건을 계약에 의한 설계를 사용하면 아래와 같이 좀 더 명확하게 설명할 수 있다.

> ***서브타입이 리스코프 치환 원칙을 만족시키기 위해서는 클라이언트와 슈퍼타입 간에 체결된 ‘계약'을 준수해야한다***.
> 

계약의 관점에서 상속이 초래하는 문제는 자식 클래스가 부모 클래스의 메서드를 오버라이딩한다는 것이다. 그렇다면 우린 자식 클래스가 부모 클래스의 서브타입이 되기 위해 어떤 조건을 만족시켜야 할까.

1. 서브타입에 더 강력한 사전조건을 정의할 수 없다.
2. 서브타입에 슈퍼타입과 같거나 더 약한 사전조건을 정의할 수 있다.
3. 서브타입에 슈퍼타입과 같거나 더 강한 사후조건을 정의할 수 있다.
4. 서브타입에 더 약한 사후조건을 정의할 수 없다.

계약에 의한 설계는 클라이언트의 관점에서의 대체 가능성을 계약으로 설명할 수 있다.