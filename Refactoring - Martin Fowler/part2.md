# 리팩토링 Part 2 : 리팩토링 개론

### 머릿말

이전 장에서는 맛보기 예제를 통해서 리팩토링의 개념을 가볍게 알아보고 직접 리팩토링을 진행해보며 어떻게 하는 것인지를 파악했다. 이번 장에서는 이론적인 리팩토링을 들여다본다. 리팩토링의 주요 원리와 리팩토링할 때 고려해야하는 사안이 그 주제이다. 시작하자.

---

### 리팩토링은 무엇인가

리팩토링은 무엇일까요? 보통의 정의는 ‘기능은 그대로 둔 채 소프트웨어의 구조를 변경하는 것이다’ 라고 나온다. 하지만 사실 리팩토링은 리팩토링이 무엇인가보다 그 목적이 어디에 있는지가 더욱 중요하다. 리팩토링의 목적은 **소프트웨어를 더 이해하기 쉽고 수정하기 쉽게 만드는 것**이다. 다만 겉으로 드러나는 소프트웨어 기능에 영향을 주지 않을 뿐이다. 

리팩토링은 추상화된 개념이라고 생각된다. 수많은 기법을 보유하고 있으며 뚜렷한 개념을 정의하기도 힘들다. 두루뭉실하게 소프트웨어를 수정하는 것이다. 그래서 누군가는 단순 코드 정리 작업이라고 묻기도 한다. 하지만 앞서 말했듯 리팩토링의 개념은 무엇을 하고자 하는지를 정의할 때 훨씬 이해하기 쉽다. 목적을 반영한 개념을 단어로 표현하자면 리팩토링은 **‘코드 효율성의 향상’**과 **‘구조의 체계화’**다. 

---

### 리팩토링은 왜 해야 하나

리팩토링은 만병통치약(빨간 약)이 아니다. 적용시킨다고 개선되는 것이 아니다. 그 목적은 코드를 언제든 쉽게 이해하도록 변경하는 데에 있다. 그렇다면 이 목적은 어떤 이점을 발휘할까. 한번 확인해보자.

1. **소프트웨어 설계가 개선되니까**
    
    ‘오늘은 내일의 어제가 된다’ 라는 말이 있다. 이 말은 소프트웨어에게도 적용된다. 프로그램 설게는 초기에는 그 당시의 상황을 최대한 반영한 최적의 구조였지만 시간이 지나며 설계를 완벽하게 이해하지 못한 요구사항들이 추가되고 크기가 커지며 설계는 점점 노후된다. 점점 코드들은 이해하기 힘들어지며 설계는 파악하기 힘들어진다. 리팩토링은 이 때 필요한 행동이다. 
    
    사실 설계는 한번 엉망이 되기 시작하면 뒤이어 진행되는 설계들도 빈틈이 생긴 벽돌에 쌓인 벽돌처럼 위험하게 흔들린다. 그리고 이 벽돌들은 맨 처음 빈틈을 바로 잡기 전까진 계속해서 휘청거리며 악순환의 고리를 끊기 쉽지 않다. 따라서 빈틈들을 방지하기 위해서 리팩토링이 필수적이다. 
    
    같은 기능을 가진 중복 코드들을 제거하고, 부적절한 위치에 있는 코드들을 수정하며 설계를 개선하는 리팩토링은 망가진 소프트웨어 설계를 개선하고, 정기적인 리팩토링은 애초에 설계를 망가뜨리지 않기 위해 필요한  백신이라는 것을 기억하자.
    
2. **소프트웨어를 이해하기가 더 쉬워지니까**
    
    컴퓨터가 이해하는 코드는 누구나 작성할 수 있다. 하지만 사람이 이해하는 코드는 작성하기 쉽지 않다. 또한대부분의 코드들은 컴퓨터가 아닌 사람에게 읽힌다. 따라서 개발자가 단순히 구현에 집중하다 보면 나중에 수정해야할 개발자가 고려되지 않는다. 결국은 사람이 읽기 쉬운 코드가 아닌 자신만 읽을 수 있는 코드가 탄생한다. 따라서 우리는 이를 좀더 인간친화적으로 변경해야 한다.
    
    이 때 사용할 수 있는 방법이 바로 리팩토링이다. 리팩토링을 통해 불완전한 구조를 갖거나 코드의 존재 의미를 명확하게 캐치할 수 없는 부분들을 수정한다.프로그래밍에서 중요한 것은 결국 의도한 바를 정확히 전달하는 것이기 때문이다. 
    
3. **버그를 찾기 쉬워지니까**
    
    우리는 리팩토링을 통해 기능을 명확하고 근본적으로 이해한다. 이를 통해 프로그램의 설계를 머릿속에 기억한다. 따라서 버그의 발견도 자연스레 쉬워진다.
    
4. **프로그래밍 속도가 빨라지니까**
    
    프로그래밍 속도가 빠르다는 건 생산성이 좋다는 의미다. 빠른 시간 안에 요구사항을 만족하는 제품을 만들어낸다. 하지만 언제까지나 그렇지는 않다는 것도 알아야 한다. 사실 리팩토링은 누군가는 코드 품질이 좋아진다는 장점을 가지지만 이것이 개발 속도까지 빠르게 하는지는 의문을 갖는 경우가 많다. 하지만 우린 결국 한계에 맞닥뜨린다. 
    
    수많은 중복과 부적절한 설계로 이뤄진 애플리케이션은 개발 속도가 급격하게 하락한다. 달리기를 예시로 들어보자. 관절과 근육을 고려하지 않고 달리는 주법은 당시에는 한계점에 임박하지 않고 좀더 빠르게 달릴수도 있다. 물론 더 빠르게 달릴 것이라는 보장 역시 없다. 하지만 임계점이 다다르면 달리지 못할지도 모른다. 따라서 우린 우리의 신체를 다치지 않도록 주법을 연마해야한다. 그래야 다치지 않고 끝까지 달릴 수 있다. 즉, 깔끔한 설계는 소프트웨어의 개발 속도를 유지하기 위한 필수 불가결한 요소다. 만약 이것을 지키지 않는다면 부러진 다리처럼 더이상 제 기능을 할 수 없을지도 모르니까.
    

---

### 리팩토링은 어떨 때 필요한가

앞에서 우린 리팩토링의 목적과 이점을 알아봤다. 그리고 그 예시로 런닝을 들었었다. 같은 예시로 한번 더 살펴보자. 우린 과연 언제 주법의 변화를 꾀하는가? 사실 대부분의 사람들은 통증이 느껴지거나 한계에 부딪힐 때 주법에 대한 의문을 가진다. 주기적으로 주법에 대한 공부를 하진 않는다. 달려야 하는데 통증때문에 달릴 수 없을때 주법에 대한 고민을 갖는다. 소프트웨어도 똑같다. 그렇다면 소프트웨어는 이 시점이 언제인지 알아보자.

1. **같은 작업의 삼진 아웃 때**
    
    여기서 삼진은 리팩토링, 스트라이크는 작업의 중복이다. 어떤 작업을 처음할 땐 그냥 하면 된다. 그리고 두번째 작업에서 중복이라면 이 때도 그냥 하면 된다. 하지만 마지막 삼진을 당하게 될 작업의 중복엔 리팩토링을 하면 된다. 효율성의 관점이라고 생각한다. 모든 중복을 제거하는 것은 쉽지 않다. 하지만 동일한 작업에 세번이나 반복되는 것은 분명 생산성과 효율성에 의심을 가져야 한다. 따라서 세번이다.
    
2. **기능을 추가할 때**
    
    새 기능을 추가할 때와 기능을 추가하려 할 때 설계때문에 도저히 못해먹겠다고 느낄 때, 두가지 상황에 우린 리팩토링이 필요하다. 새 기능을 추가할 때는 새로 프로덕션 코드의 집합에 입성하려는 코드가 최대한 이해하기 쉽고 깔끔한 버전을 위해서 리팩토링이 필요하다. 설계가 발목을 잡을 땐 생각만 하지 말고 바로 시작하자. 그래야 원래 하려던 기능도 빠르게 구현할 수 있다.
    
3. **코드를 검수할 때**
    
    정기적인 코드 검수는 효과적인 작업이다. 팀 전체에 코드가 퍼지기 때문이다. 알아보기 어려운 코드들과 선임 개발자들만 알고 있는 코드같은 문제점들이 자연스레 해결된다. 여기에 리팩토링을 더하면 코드 검수 결과는 보다 효과적이 된다. 문제점들을 개선할 수 있는 리팩토링에 대한 여지들이 여기저기 내재되어 있다가 검수를 통해 빛을 보기 때문이다. 
    

> **리팩토링의 효용성**

프로그램은 현재와 미래의 기능을 둘다 가진다. 현재도 중요하지만 미래를 대비하는 일은 더욱더 중요하다. 프로그램뿐만 아니라 개발자에게도 동일하게 적용되는 사실이다. 현재에만 집중하면 내일을 살아가기 버겁다. 리팩토링은 이런 점을 해결해준다. 과거의 판단이 오늘은 틀렸다는 걸 확인했다면 바로 수정해라. 프로그램은 아래 4가지의 상황에서 수정이 어렵다.

- 코드를 알아보기 힘들 때 → 알아보기 쉬운 코드
- 중복된 로직이 들어 있을 때 → 모든 로직은 한 곳에만 존재 
- 추가 기능을 넣어야 해서 실행중인 코드를 변경해야할 때 → 기존 기능을 건드리지 않고
- 조건문 구조가 복잡할 때 → 조건문 구조가 최대한 간결하게

프로그램은 위 4가지의 상황을 겪지 않는 상황을 벗어나게끔 항상 개선되어야 한다. 리팩토링은 기능을 바꾸는 작업이 아닌 위 성질을 벗어나도록 변경하는 작업이라는 점을 명심하자
> 

---

### 팀장에게 어떻게 말을 꺼내나

코드 검수가 없다 해도 본문에선 그냥 하라고 말한다. 팀장들이 리팩토링을 거부하는 탓은 대부분 일정에 대한 압박 때문이니까. 하지만 리팩토링을 통해 기능을 추가하는 속도가 같거나 오히려 더 빠르다면? 그냥 하면 된다. 

> *컴퓨터 과학에선 모든 문제의 해결책이 인다이렉션 계층을 하나 더 만드는 것이라고 가르친다.
- 드니스 드브룰러*
> 

여기서 인다이렉션은 ‘간접접근’의 의미라고 이해하자. 중개자의 역할을 하는 하나의 층이 인다이렉션 계층이다. 위 인용문에서는 간접 접근 계층을 만드는 것이 해결책이라고 하지만, 사실은 그렇지 않을수도 있다. 그 이유는 관리 포인트의 증가다. 

예를 들어 X 작업을 요청하는 A, X 작업을 수행하는 Y만 있으면 작업이 원만하게 수행된다. 하지만 인다이렉션 계층 I를 만들게 되면 굳이 Y에게 X작업을 요청해주는 I를 추가로 만들어 2개의 관리 포인트가 3개로 늘어난다. 이런 단점에도 불구하고 인다이렉션 계층을 ‘모든 문제의 해결책’이라고 하는 이유는 뭘까. 확인해보자.

1. **로직을 공유**
    
    여러 위치에서 호출되는 하위 메서드나 하위 클래스가 공유하는 상위 클래스의 메서드 로직을 공유할 수 있다
    
2. **의도와 구현부를 따로 나타냄**
    
    클래스와 메서드의 이름을 정해 의도한 바를 드러내고 내부 코드를 통해 의도를 구현한 방법을 보여줄 수 있다. 이를 통해 코드 구조에 대한 주요 정보를 보다 잘 드러낸다.
    
3. **수정 부분을 분리**
    
    객체가 여러 곳에 사용될 때 특정 상황에 다르게 동작해야하는 경우를 그대로 객체에 반영하면 다른 곳에서 잘못 동작할 위험이 있다. 이 경우 하위 클래스를 통해 참조하도록 변경하자.
    
4. **조건문을 코드화**
    
    우린 객체지향의 재정의 메시지라는 메커니즘을 통해 조건문을 유연하게 표현할 수 있다.
    

결국 인다이렉션은 작업을 요청하는 객체와 수신하는 커뮤니케이션 사이에 작업을 위임하는 층을 만들어 변경을 최소화하기 위한 작업이다. 즉 N:N, N:1의 요청을 효율적으로 처리하기 위함이기 때문에 만약 쓸데없는 중개 메서드 혹은 한 곳에서만 사용하는 컴포넌트를 발견한 경우는 삭제하면 된다. 이 경우의 인다이렉션은 앞서 말한 쓸데없는 관리 포인트에 불과하기 때문이다. 

이 부분은 객체지향에서 책임을 적절하게 할당하고, 역할을 생성해 추상화하는 것과 같은 개념을 공유하는 것으로 보여진다. 자세한 내용은 오브젝트 서적에서 확인하자.

---

### 리팩토링 관련 문제들

리팩토링은 앞서 말한 장점들도 뛰어나지만 어떤 경우에는 잠재적 위험성을 내포하기도 하며, 해결하기 힘든 경우도 있다. 이런 경우를 한번 알아보자.

1. **데이터베이스**
    
    대부분의 비즈니스 애플리케이션가 내부 로직들은 데이터베이스 스키마와 강한 결합도를 갖는다. 이 때문에 데이터베이스 수정은 사실 쉽지 않다. 심지어 변경한다고 해도 기존 데이터들을 어떻게 이전할 것인지도 꽤 큰 숙제다. 따라서 이런 경우 별도의 소프트웨어 계층을 두어 유연성을 확보하기도 한다
    
2. **인터페이스 변경**
    
    객체지향의 장점 중 하나는 인터페이스를 그대로 둔 채로 내부의 구현 코드만 수정할 수 있다는 것이다. 하지만 문제는 리팩토링에서는 대부분 인터페이스를 건드린다는 점에 있다.
    
3. **리팩토링을 어렵게 하는 설계를 수정하는 일**
    
    설계에 오류가 있고, 요구사항이 변경되는 경우에도 리팩토링이 자유로울까? 이 경우도 물론 리팩토링으로 해결된다. 프레임워크 혹은 연동 기술에 대한 선택에 대한 판단을 배제하면 가능한 경우도 많다.
    
4. **리팩토링하면 안되는 상황**
    
    기존 코드가 너무 복잡해 차라리 새로 작성하는게 나을 것 같다면 새로 작성하라. 하지만 이 판단은 쉽지 않다. 따라서 코드가 동작하지 않는다면 새로 작성하라.
    

---

### 리팩토링과 설계

애플리케이션을 만들 때 사전 설계는 과연 얼마만큼의 비중을 차지할까. 아마 틀을 잡는 작업이니 꽤 중요할 것이다. 또한 복잡한 요구사항이 들어올 것이 예상되고 단순한 구조로는 해결이 안될 것 같다는 생각이 들기 시작한다. 따라서 이런 경우를 최대한 대비하기 위해 최대한 유연하고 최상의 솔루션을 가져오기 위해 노력할 것이다. 하지만 결국 변경은 일어난다. 이 때 만약 리팩토링이 사전 설계의 과정에서 포함되었다면 어떨까.

사전 설계는 분명히 필요하다. 하지만 리팩토링이 가정된다면 완벽한 솔루션 대신 적당한 솔루션만 찾으면 된다. 왜냐면 우리가 처음 생각했던 최상의 솔루션은 사실 끊임없이 변화하는 요구사항에 적당하지 않을수도 있기 때문이다. 리팩토링은 진행되면 진행될수록 기존의 설계를 보완해주는 역할을 담당한다. 사전 설계에서 100점을 맞으면 좋겠지만, 그렇지 않다 해도 충분히 100점에 가까운 설계를 리팩토링을 통해 얻을 수 있다.

---

### 리팩토링과 성능

소프트웨어에게 성능은 아주 중요하다. 본문에서는 소프트웨어를 작성하는 일반적인 방법 3가지를 소개한다. 첫번째는 설계의 각 부분에 자원별 예산을 할당하는 것이다. 하지만 이 부분은 실시간 시스템이 아닌 시스템에 적용하기엔 지나치다. 두번째는 성능에 대해 꾸준히 관심을 갖고 개발하는 것이다. 이 부분은 효율성이 떨어진다. 세번째는 개발자가 성능 최적화 단계 전까지는 성능을 신경쓰지않고 프로그램을 잘 쪼개난 뒤, 성능 최적화 단계에서 프로그램을 튜닝하는 것이다. 

프로그램을 잘 쪼개면 성능 튜닝에 할애할 시간이 생긴다. 그 이유는 기능 추가가 쉽고 빠르게 이루어지기 때문이다. 또한 성능을 분석할 때 더 정밀하게 분석할 수 있다. 영역이 분리되어 있기 때문에 병목 지점을 빠르게 찾을 수 있다. 리팩토링은 소프트웨어 개발 기간을 단축하는데 도움이 된다. 물론 단기적으로는 소프트웨어가 느려지지만 최적화를 거치고 튜닝하기가 쉬어져 결국은 소프트웨어 개발이 빨라지게 된다.

---

### 맺음말

이번 장에서는 리팩토링은 무엇인지 이론적인 부분에서 알아보며 장점과 필요한 시기 등 리팩토링의 원리를 확인했다. 또한 소프트웨어 설계에서 리팩토링이 어떤 의미를 갖는지를 되돌아보며 우리가 주기적인 리팩토링을 해야하는 이유까지 알았다. 다음은 정확하게 언제 적용해야 하는지를 알아보려 한다.