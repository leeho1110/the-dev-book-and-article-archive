# 5장: 서비스 추상화

이번 장에서는 지금까지 작성한 DAO에 트랜잭션을 적용해보겠습니다.

---

### 1. 사용자 레벨 관리 기능 추가

- private static final in로 상수를 정의하는 것보단 enum을 활용하자.
- JDBC가 사용하는 SQL은 사실 컴파일 과정에서 검증되지 않는 단순 문자다.
    - 즉 문법 오류나 오타를 발견하는 것이 오직 사람의 몫이라는 것이다.
- 자 그렇다면 사용자를 관리하는 로직을 실제로 작성하자.
    - DAO는 데이터 액세스에 대한 책임이 있는 곳이지, 비즈니스 로직이 있을 곳은 아니다.
    - UserService로 네이밍하자. 어딘가 익숙하다.
- 본문에서 UserService.upgradeLevels() 메서드를 구현한 곳은 서비스 레이어다. 추후에 과연 도메인 모델과 분리되어 바뀔지 궁금하다.
- 그럼 그렇지, 코드 개선 부분이 나온다. 고려해야하는 항목은 아래와 같다.
    - 코드에 중복된 부분은 없는가?
    - 코드가 무엇을 하는 것인지 이해하기 불편하지 않은가?
    - 코드가 자신이 있어야 할 자리에 있는가?
    - 앞으로 변경이 일어난다면 어떤 것이 있을 수 있고, 그 변화에 쉽게 대응할 수 있게 작성되어 있는가?
- upgradeLevels() 리팩토링
    - ASIS
        
        ```java
        public void upgradeLevels() {
        		List<User> users = userDao.getAll();
        
        		for(User user : users) {
        				Boolean changed = null;
        				if(user.getLevel() == Level.BASIC && user.getLogin() >= 50) {
        						user.setLevel(Level.SILVER);
        						changed = true;
        				} else if(user.getLevel() == Level.SILVER && user.getLogin() >= 30){
        						user.setLevel(Level.GOLD);
        						changed = true;
        				} else if(user.getLevel() == Level.GOLD) {
        						changed = false;
        				} else {
        						changed = false;						
        				}
        
        				if(changed) {
        						userDao.update(user);
        				}
        		}
        }
        ```
        
        asis는 자주 변경될 가능성이 있는 구체적인 내용이 추상적인 로직의 흐름과 함께 섞여있다. 거기에 더해 if문이 레벨의 개수에 비례해 반복되기까지 한다. 수정해보자.
        
    - TOBE
        
        ```java
        public void upgradeLevels() {
        		List<User> users = userDao.getAll();
        		for(User user : users) {
        				if(canUpgradeLevel(user)){
        					upgradeLevel(user);
        				}
        		}
        }
        ```
        
        if 조건절과 레벨을 올리는 코드임이 명확히 드러나도록 구체적인 내용을 담아 함수명과 조건식을 작성했다. 여기서 추출된 메서드도 확인해보자.
        
        ```java
        private boolean canUpgradeLevel(User user){
        		Level currentLevel = user.getLevel();
        		switch(currentLevel) {
        				case BASIC: return (user.getLogin()) >= 50);
        				case SILVER: return (user.getRecommend()) >= 30);
        				case GOLD: return false;
        				default: throw new IllegalArgumentException(
        								"Unknown Level: " + currentLevel);
        		}
        }
        
        private void upgradeLevel(User user){
        		if(user.getLevel() == Level.BASIC) {
        				user.setLevel(Level.SILVER);
        		} else if(user.getLevel() == Level.SILVER) {
        				user.setLevel(Level.GOLD);
        		};
        		userDao.update(user);
        }
        ```
        
        그런데 upgradeLevel() 메서드를 잘 보면 여러가지 문제점들이 존재한다.
        
        - User 객체의 level 필드를 변환하는 로직이 그대로 노출하며 캡슐화를 위반한다.
        - level이 늘어날수록 조건문이 늘어나는 문제도 여전하다.
        - 즉 세부 구현에 대한 내용이 그대로 코드에 드러나있다.
- 자 리팩토링을 리팩토링해보자
    - 우선 레벨의 순서와 다음 단계를 결정하는 일은 Level이 할 수 있도록 위임해보자.
        
        ```java
        public enum Level {
        		GOLD(3, null), SILVER(2,GOLD), BASIC(1,SILVER);
        
        		private final int value;
        		private final Level next; // 다음 단계에 대한 정보를 스스로 갖고 있다.
        
        		Level(int value, Level next){
        				this.value = value;
        				this.next = next;
        		}
        
        		public int intValue(){
        				return value;
        		}
        
        		public Level nextLevel(){
        				return this.next;
        		}
        
        		public static Level valueOf(int value){
        				switch(value) {
        						case 1: return BASIC;
        						case 2: return SILVER;
        						case 3: return GOLD;
        						default: throw new AssertionError("Unknown value: " + value);
        				}
        		}
        }
        ```
        
        - UserService에서 레벨의 순서를 조건절을 통해 암시적으로 지정할 필요가 없다는 의미다.
        - 이는 비즈니스 로직에 조건절로 객체의 세부 구현을 명시한 것이나 다름이 없다.
    - 이전 코드에서는 UserService의 비즈니스 로직에서 레벨을 업그레이드하는 로직을 담고 있었다.
        - 자율적인 객체는 스스로의 상태를 스스로 제어해야 한다.
        - User 객체가 자신의 레벨을 스스로 올릴 수 있도록 책임을 위임하고 UserService는 메시지를 보내 협력하도록 변경하자.
        
        ```java
        public class User {
        		private Level level;
        		...
        		public void upgradeLevel() {
        				Level nextLevel = this.level.nextLevel(); // 킹스파?
        				if(nextLevel == null) {
        						throw new IllegalStateException(this.level + "은 업그레이드가 불가능합니다");
        				} else {
        						this.level = nextLevel;
        				}
        		}
        }
        ```
        
        - 이제 우린 Level의 다음 단계를 UserService의 비즈니스 로직을 통해 확인하지 않는다. Level 객체에게 다음 레벨이 무엇인지 메시지를 보내 처리한다. 자연스러운 캡슐화다.
        - User의 레벨을 올리는 것도 마찬가지다. 비즈니스 로직에서 User 객체의 내부 상태를 제어하지 않고, 메시지를 보내 요청한 뒤 User 객체가 스스로 내부 상태를 제어하도록 변경했다.
    - 결국 UserService는 아래처럼 간단해졌고, UserService가 갖고 있던 비즈니스 로직들은 각 객체들에게 적절히 분배되었다
        
        ```java
        public void upgradeLevel(User user) {
        		user.upgradeLevel();
        		userDao.update(user);
        }
        ```
        
        - if문장을 일일이 해석해가며 읽어야 했던 코드와 달리 각 객체가 어떤 역할을 하는지 명확히 드러난다.
        - 또한 세부 구현은 객체 뒤에 감춰졌고, 책임도 적절히 분배됐다.
- 이게 객체지향이다. 각 객체는 자신의 책임에만 충실하게 작업하며, 절대 다른 객체의 내부를 직접 헤집어놓지 않는다. 다른 객체가 해야할 일은 다른 객체에게 요청하면 그만이다. 이렇게 각자의 책임을 명확히 하고 원할한 협력 관계를 구성하는 것이 바로 객체지향이다.
    - 리팩토링을 하기 전 UserService는 객체지향이 전혀 아니다.
        - Level이 수행해야할 작업을 자신이 마음대로 가로채버리기도 하고
        - User 객체의 내부를 마음대로 헤집어 놓는다.
- 이전에 작성한 단위 테스트는 어떻게 변경할 수 있을까?
    - 역시 중복을 제거한다.
        - 숫자의 경우는 정수형 상수로 선언하자. 이를 통해 숫자에 의미를 부여할 수 있다.
        - 테스트에서는 가능한 경계 값을 사용하는게 좋다.

