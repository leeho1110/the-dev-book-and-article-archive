# 3장: 템플릿

- 1장에서는 DI를 중심적으로 살펴봤다.
    - 이 과정에서 관심사를 분리하고 확장과 변경에 용이하게 대응하는 구조를 만들었다.
- UserDao는 커넥션 연결 방법을 ConnectionMaker 인터페이스를 상속하는 클래스를 추가해
    - 자유롭게 확장할 수 있었고
    - 이를 확장하더라도 UserDao에 아무런 변경도 끼치지 않았다.
    - 이 때 지킨 원칙이 Open-Closed Principle이었다.
- 이번 장에서는 자주 변경되는 성질을 가지는 부분과 거의 변경이 일어나지 않고 일정한 패턴으로 유지되는 특성을 가진 부분을
    - 서로 독립시켜서 효과적으로 활용할 수 있도록 만드는 템플릿 기법을 알아보겠다.

---

### 1. 다시 보는 초난감 DAO

- UserDao의 deleteAll() 코드는 예외를 처리하는 부분에서 부족한 부분이 있다.
    - 에러가 발생하면 Conneciton, PreparedStatement을 정상적으로 반환하지 못한다.
    - 서버에서는 대부분 일정 갯수의 DB 커넥션을 만들고 풀에 넣어놓은 뒤 재사용한다.
    - 정상적으로 반환하지 못하면 결국 사용할 수 있는 커넥션의 개수가 부족해 리소스 부족 에러가 발생한다.
- 이 때 리소스를 반환하는 코드 조차 SQLException이 발생할 수 있기 때문에 try/catch문으로 감싸줘야 한다.
    - 너무 소스가 더러워진다.

---

### 2. 변하는 것과 변하지 않는 것

- 메소드마다 코드가 반복된다. 이 때 대부분은 복붙한다.
    - 이 방법은 위험성이 너무 높다. 인간은 항상 실수를 반복한다.
- 따라서 분리와 재사용을 위해 텀플릿 메서드 패턴을 적용시켜보자.
    - 슈퍼 클래스에서 공통 로직을 정의해놓고 변하는 부분은 추상 메서드로 둔 채 상속을 통해 하위 클래스에서 구현하도록 하는 방법
    - 이 방법은 두 가지 문제를 야기한다.
        - Resource 얻음(공통) + 쿼리(변경됨) + Resource 반납(공통)
        - 위 구조는 쿼리 부분이 변경될 때마다 신규 클래스를 추가하기 때문에
        - 개방 폐쇄 원칙을 지키긴 하지만 클래스 폭발 문제 발생
        - 또한 확장 구조가 컴파일 시점에서 고정되어 유연성이 떨어진다.
- 이를 전략 패턴으로 바꿔보자.
    - 개방 폐쇄 원칙을 잘 지키면서도 템플릿 메서드 패턴보다 유연하고 확장성이 뛰어나다.
    - DaoFactory를 만들 때 적용시켰었다.
    - 오브젝트를 아예 둘로 분리하고 클래스 레벨에서는 인터페이스를 통해서만 의존하도록 만드는 전략
        - OCP 관점으로 보면 확장에 해당하는 변하는 부분을 별도의 클래스로 만들고
        - 이를 추상화된 인터페이스를 통해 위임하는 방식이다.
        
        <p align="center"><img src="img/strategy-pattern.png"></p>
        
        > *클라이언트가 필요한 이유는 컨텍스트에서 전략을 사용하기 위해선 결국 구현 클래스를 직접 생성자를 통해 넣어줘야 했다. 그 역할을 클라이언트가 대신해준다.*
        > 
    - deleteAll()은 아래 순서로 이뤄진다.
        1. *DB 커넥션 가져오기* 
        2. *PreparedStatement를 만들어줄 외부 기능 호출하기* 
        3. *전달받은 PreparedStatement 실행하기* 
        4. *예외가 발생하면 이를 다시 메서드 밖으로 던지기* 
        5. *모든 경우에 만들어진 PreparedStatement와 Connection을 적절히 닫아주기* 
    - 여기서 컨텍스트는 변하지 않는 부분인 DB를 업데이트하는 작업이며, 컨텍스트 메서드는 deleteAll() 내부에서 쿼리를 날리는 부분이다. 그리고 전략은 PreparedStatement를 만들어주는 기능이다.
- 즉 전략(자주 변경되는 부분)인 PreparedStatement를 만들어주는 기능을 인터페이스로 만든 뒤 인터페이스의 메서드를 통해 PreparedStatement를 생성하도록 하자.
    
    ```java
    // AS-IS
    public void deleteAll() {
    
    	// 고정되는 부분 ~
    	Connection c = null;
    	PreparedStatement ps = null;
    	...
    	try {
    			c = dataSource.getConnection(); // 여기까지 고정됨
    	
    			ps = c.prepareStatement("delete from users"); // 변하는 부분
    	
    			ps.executeUpdate();
    	} catch (SQLException e){
    			throw e;
    	} finally {
    			if (ps != null) { try {ps.close); } catch (SQLException e){} }
    			if (c != null) { try {c.close); } catch (SQLException e){} }
    	}
    }
    ```
    
    ```java
    // TO-BE
    // 전략을 인터페이스로 구현
    public interface StatmentStrategy {
    	PreparedStatement makePreparedStatement(Connection c) throws SQLException;
    }
    
    // 인터페이스로 생성한 전략을 상속(구현)하는 구체 클래스 
    public class DeleteAllStatement implements StatementStrategy {
    	public PreparedStatement makePreparedStatement(Connection c) throws
    			SQLException {
    		PreparedStatement ps = c.prepareStatement("delete from users");
    		return ps;
    	}
    }
    
    // Result
    public void deleteAll() {
    	...
    	try {
    			c = dataSource.getConnection();
    	
    			StatmentStrategy strategy = new DeleteAllStatement();
    			ps = strategy.makePreparedStatement(c);
    	
    			ps.executeUpdate(); 	
    	} catch (SQLException e) {
    		...
    }
    ```
    
    - 여기서도 결국은 구체 클래스를 직접 new 생성자(DeleteAllStatement)를 통해 컨텍스트 안에서 생성과 사용을 제어하고 있다.
        - UserDao의 ConnectionMaker의 구체 클래스를 생성자 안에서 직접 new 연산자로 생성하던 것과 같은 패턴이다.
        - 이를 해결하기 위해 컨텍스트(UserDao)가 필요로 하는 전략(ConnectionMaker)의 특정 구현 클래스(DConnectionMaker) 오브젝트를 클라이언트(UserDaoTest)가 만들어서 제공하는 방법을 사용했다.
- 이 때 필요한건 역시 클라이언트다.
    
    ```java
    // 여기서 인자로 전달받는 StatementStrategy는 클라이언트가 컨텍스트를 호출할 때 넘겨준다
    public class UserDao {
    	...
    	public void jdbcContextWithStatementStrategy(StatementStrategy stmt) {
    
    			Connection c = null;
    			PreparedStatement ps = null;
    			
    			try {
    					c = dataSource.getConnection(); 
    			
    					ps = stmt.makePreparedStatement(c); // 이 때 stme는 DeleteAllStatement
    			
    					ps.executeUpdate();
    			} catch (SQLException e){
    					throw e;
    			} finally {
    					if (ps != null) { try {ps.close); } catch (SQLException e){} }
    					if (c != null) { try {c.close); } catch (SQLException e){} }
    			}
    	}
    }
    
    ```
    
    - 여기서 우린 기존 컨텍스트 역할을 하던 deleteAll()을 jdbcContextWithStatementStrategy()로 분리한 뒤, 이를 호출하도록 구조를 바꿨다.
    - 따라서 deleteAll()이 클라이언트, jdbcContextWithStatementStrategy()가 컨텍스트가 되었다.
        - 둘의 클래스가 분리되지 않았지만 전략 패턴에서 의도한 바를 잘 수행하고 있다.
- add() 메서드에도 적용해보자.
    
    ```java
    public class AddStatement implements StatementStrategy {
    		User user;
    
    		public AddStatement(User user) {
    			this.user = user;
    		}
    
    		public PreparedStatment makePreparedStatement(Connecion c) {
    			...
    			ps.setString(1, user.getId());
    
    			return ps;
    		}
    }
    
    public class UserDao { 
    		public void add(User user) throws SQLException {
    				StatementStrategy st = new AddStatement(user);
    				jdbcContextWithStatementStrategy(st);
    		}
    }
    ```
    
- 하지만 여기서도 역시 불만이 있다. 인터페이스를 통해 구현 클래스를 쿼리마다 생성해줘야 한다는 것이다.
    - 즉 여기서도 클래스 폭발 문제가 발생한다.
    - 런타임에서 동적으로 오브젝트를 DI해준다는 점을 제외하면 템플릿 메서드 패턴과 똑같다.
    - 이 문제는 어떻게 해결해야 할까.
- 첫 번째 해결책은 로컬 클래스다.
    - 클래스 폭발 문제가 발생하는 전략을 구현하는 클래스를 각기 파일이 아닌 내부 클래스로 정의해버리자.
    
    ```java
    public class UserDao {
    	public void add(User user) throws SQLException {
    
    		// 내부 클래스 정의
    		class AddStatement implements StatementStrategy {
    			User user;
    	
    			public AddStatement(User user) {
    				this.user = user;
    			}
    	
    			public PreparedStatment makePreparedStatement(Connecion c) {
    				...
    				ps.setString(1, user.getId());
    
    				return ps;
    			}
    		}
    		// 내부 클래스 정의 끝
    		
    		// add 메서드 내부 로직을 위에서 생성한 내부 클래스를 통해 수행
    		StatementStrategy st = new AddStatement(user);
    		jdbcContextWithStatementStrategy(st);
    }
    ```
    
    - 다른 클래스 내부에 정의되는 클래스를 중첩 클래스라고 한다.
        - 독립적으로 오브젝틀 만들어질 수 있는 스태틱 클래스(static class)
        - 자신이 정의된 클래스의 오브젝트 안에서 만들어질 수 있는 내부 클래스 (inner class)로 구분됨
            1. 멤버 필드처럼 오브젝트 레벨에 정의되는 멤버 내부 클래스(member inner class)
            2. 메소드 레벨에 정의되는 로컬 클래스(local class)
            3. 이름을 갖지 않는 익명 내부 클래스(annonymous inner class)
- 두 번째 해결책인 익명 내부 클래스다.
    - 어차피 AddStatment 클래스는 add() 메서드에서만 사용된다. 내친 김에 좀더 간결하게 가보자.
    
    ```java
    public class UserDao {
    	public void add(User user) throws SQLException {
    
    		// 메서드에 필요한 StatementStrategy 구현 클래스를 바로 정의한다.
    		jdbcContextWithStatementStrategy(
    			new StatementStrategy() {
    				public PreparedStatment makePreparedStatement(Connecion c) {
    						...
    						ps.setString(1, user.getId());
    	
    						return ps;
    				}
    			}
    		);
    	}
    }
    ```
    

---

### 4. 컨텍스트와 DI

- 위에서는 전략 패턴을 적용하고 로컬 클래스, 익명 내부 클래스를 사용해 클래스 폭발 문제를 방지했다.
    
    ```java
    // add(): 클라이언트
    public void add(User user) throws SQLException {
    	// jdbcContextWithStatementStrategy: 컨텍스트
    	jdbcContextWithStatementStrategy(
    		// new StatementStrategy(): 개별 전략
    		new StatementStrategy() {
    			// makePreparedStatement(): 컨텍스트 메서드
    			public PreparedStatment makePreparedStatement(Connecion c) {
    					...
    					ps.setString(1, user.getId());
    
    					return ps;
    			}
    		}
    	);
    }
    ```
    
    - 이 때 jdbcContextWithStatementStrategy() 메서드는 다른 DAO에서도 재사용이 가능하다. 따라서 이를 UserDao 클래스 밖으로 독립시키자.
- 메서드를 분리해놓을 클래스를 생성하고 옮겨보자
    
    ```java
    public class JdbcContext {
    	private DataSource dataSource;
    
    	public void setDataSource(DataSource dataSource) {
    			this.dataSource = dataSource;
    	}
    
    	public void workWithStatementStrategy(StatementStrategy stmt) throws 
    		SQLException {
    			Connection c = null;
    			PreparedStatement = ps = null;
    		
    			try {
    					c = this.dataSource.getConneciton();
    
    					ps = stmt.makePreparedStatement(c);
    
    					ps.executeUpdate();
    			} catch (SQLException e) {
    			...
    	}
    }
    ```
    
    - 변경 전에 DataSource를 필요로 하던 객체는 UserDao였다. 하지만 지금은 새로 생성된 JdbcContext가 DataSource를 필요로 한다.
    - setter 메서드를 통해 컨테이너가 수정자 주입을 하도록 변경했다.
- 이제 UserDao가 JdbcContext를 사용해 쿼리를 날릴 수 있도록 바꿔보자.
    
    ```java
    public class UserDao {
    	...
    	private JdbcContext jdbcContext;
    	
    	// DI 받도록 만들어준다
    	public void setJdbcContext(JdbcContext jdbcContext) {
    		this.jdbcContext = jdbcContext
    	}
    
    	public void add(User user) { ... }
    	public void deleteAll() { ... }
    }
    ```
    
- 자 여기서 한번 생각해보자, 지금까지의 DI는 클래스 레벨에서 세부사항(인터페이스를 구현한 구체 클래스)와 의존관계가 생기지 않도록 인터페이스를 적용했다.
    - 그런데 여기선 JdbcContext 구체 클래스를 직접 주입받아서 사용하고 있다.
    - 인터페이스를 사용하지 않았으니 올바르지 않은 것일까?
    - 인터페이스를 두는 목적은  컴파일 시점에서 세부 구현사항에 대한 의존관계를 끊고, 런타임에 동적으로 관계를 주입해주는 것이다.
- 그렇다면 JdbcContext와 UserDao 사이를 왜 DI 구조로 바꾼 것일까?
    - JDBC 컨텍스트 메소드를 제공해주는 서비스 오브젝트로써의 가치를 갖는다.
        - 또한 필드로 갖고 있는 필드도 상태를 갖고 있지 않다.
    - DI를 통해 다른 빈에 의존하고 있다. dataSource 프로퍼티를 통해 DataSource 객체를 주입받는다.
        - 앞서 말했듯 스프링 컨테이너를 통해 빈을 주입받으려면 주입받는 본인도 컨테이너에 빈으로 등록되어 있어야 한다.
    - 인터페이스를 사용하지 않는 이유는 무엇일까?
        - 인터페이스가 없으면 두 클래스는 강하게 서로 결합된다. 즉 반드시 둘은 뭉쳐있어야 한다.
        - 만약 데이터베이스를 핸들링할 때 JDBC가 아닌 ORM을 사용한다면 JdbcContext는 분명 다른 구현으로 변경되야 한다. 이럴 땐 인터페이스를 사용하지 않아도 좋다.
- 수동 DI를 적용해보자
    - 현재의 의존 관계는 {UserDao → (JdbcContext} → DataSource) 이고 세 클래스 각기 다른 @Bean을 통해 모두 스프링 컨테이너에게 객체를 주입받고 있다.
    - 이를 UserDao가 DataSource를 컨테이너에게 주입받아 JdbcContext에 넣어주도록 바꿔보자.
        - 이 과정에서 JdbContext는 싱글톤이 보장되지 않고, Dao마다 하나씩 생성된다.
        - 갯수가 몇만개가 되는 것도 아니고, 상태 정보도 없다. 또한 객체의 라이프사이클이 짧은 것이 아니기에 괜찮을 것이다.
    
    ```java
    public class UserDao {
    	...
    	private JdbcContext jdbcContext;
    	
    	// 수정자 메서드임과 동시에 JdbcContext를 생성하고
    	// 스프링 컨테이너로부터 주입받은 DataSource를 주입해주는 역할까지 수행한다.
    	public void setDataSource(DataSource dataSource) {
    			this.jdbcContext = new JdbcContext();
    			
    			this.jdbcContext.setDataSource(dataSource);
    
    			this.datasource = datasource;
    	}
    }
    ```
    
    - 이렇게 변경한 이유는 UserDao와 JdbcContext는 위에서 말했듯, 굉장히 긴밀한 관계를 가져 굳이 빈으로 처리할 필요가 없다는 것이 첫 번째였고
    - 두 번째로는 내부에서 의존성을 갖는 객체를 직접 생성함과 동시에 다른 오브젝트에 대한 DI를 직접 본인이 제어할 수 있기 떄문이다.
        - 이를 통해 외부에 컴파일 단계에서 구체적인 의존관계가 노출되는 문제점을 해결할 수 있었다.